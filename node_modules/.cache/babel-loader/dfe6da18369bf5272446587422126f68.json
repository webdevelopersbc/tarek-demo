{"ast":null,"code":"import { types as sdkTypes } from '../util/sdkLoader';\nconst {\n  LatLng: SDKLatLng,\n  LatLngBounds: SDKLatLngBounds\n} = sdkTypes;\n\nconst placeOrigin = place => {\n  if (place && place.geometry && place.geometry.location) {\n    return new SDKLatLng(place.geometry.location.lat(), place.geometry.location.lng());\n  }\n\n  return null;\n};\n\nconst placeBounds = place => {\n  if (place && place.geometry && place.geometry.viewport) {\n    const ne = place.geometry.viewport.getNorthEast();\n    const sw = place.geometry.viewport.getSouthWest();\n    return new SDKLatLngBounds(new SDKLatLng(ne.lat(), ne.lng()), new SDKLatLng(sw.lat(), sw.lng()));\n  }\n\n  return null;\n};\n/**\r\n * Get a detailed place object\r\n *\r\n * @param {String} placeId - ID for a place received from the\r\n * autocomplete service\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n *\r\n * @return {Promise<util.propTypes.place>} Promise that\r\n * resolves to the detailed place, rejects if the request failed\r\n */\n\n\nexport const getPlaceDetails = (placeId, sessionToken) => new Promise((resolve, reject) => {\n  const serviceStatus = window.google.maps.places.PlacesServiceStatus;\n  const el = document.createElement('div');\n  const service = new window.google.maps.places.PlacesService(el);\n  const fields = ['address_component', 'formatted_address', 'geometry', 'place_id'];\n  const sessionTokenMaybe = sessionToken ? {\n    sessionToken\n  } : {};\n  service.getDetails({\n    placeId,\n    fields,\n    ...sessionTokenMaybe\n  }, (place, status) => {\n    if (status !== serviceStatus.OK) {\n      reject(new Error(`Could not get details for place id \"${placeId}\", error status was \"${status}\"`));\n    } else {\n      resolve({\n        address: place.formatted_address,\n        origin: placeOrigin(place),\n        bounds: placeBounds(place)\n      });\n    }\n  });\n});\n\nconst predictionSuccessful = status => {\n  const {\n    OK,\n    ZERO_RESULTS\n  } = window.google.maps.places.PlacesServiceStatus;\n  return status === OK || status === ZERO_RESULTS;\n};\n/**\r\n * Get place predictions for the given search\r\n *\r\n * @param {String} search - place name or address to search\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n * @param {Object} searchConfigurations - defines the search configurations that can be used with\r\n * the autocomplete service. Used to restrict search to specific country (or countries).\r\n *\r\n * @return {Promise<{ search, predictions[] }>} - Promise of an object\r\n * with the original search query and an array of\r\n * `google.maps.places.AutocompletePrediction` objects\r\n */\n\n\nexport const getPlacePredictions = (search, sessionToken, searchConfigurations) => new Promise((resolve, reject) => {\n  const service = new window.google.maps.places.AutocompleteService();\n  const sessionTokenMaybe = sessionToken ? {\n    sessionToken\n  } : {};\n  service.getPlacePredictions({\n    input: search,\n    ...sessionTokenMaybe,\n    ...searchConfigurations\n  }, (predictions, status) => {\n    if (!predictionSuccessful(status)) {\n      reject(new Error(`Prediction service status not OK: ${status}`));\n    } else {\n      const results = {\n        search,\n        predictions: predictions || []\n      };\n      resolve(results);\n    }\n  });\n});\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Cut some precision from bounds coordinates to tackle subtle map movements\r\n * when map is moved manually\r\n *\r\n * @param {LatLngBounds} sdkBounds - bounds to be changed to fixed precision\r\n * @param {Number} fixedPrecision - integer to be used on tofixed() change.\r\n *\r\n * @return {SDKLatLngBounds} - bounds cut to given fixed precision\r\n */\n\nexport const sdkBoundsToFixedCoordinates = (sdkBounds, fixedPrecision) => {\n  const fixed = n => Number.parseFloat(n.toFixed(fixedPrecision));\n\n  const ne = new SDKLatLng(fixed(sdkBounds.ne.lat), fixed(sdkBounds.ne.lng));\n  const sw = new SDKLatLng(fixed(sdkBounds.sw.lat), fixed(sdkBounds.sw.lng));\n  return new SDKLatLngBounds(ne, sw);\n};\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Check if given bounds object have the same coordinates\r\n *\r\n * @param {LatLngBounds} sdkBounds1 - bounds #1 to be compared\r\n * @param {LatLngBounds} sdkBounds2 - bounds #2 to be compared\r\n *\r\n * @return {boolean} - true if bounds are the same\r\n */\n\nexport const hasSameSDKBounds = (sdkBounds1, sdkBounds2) => {\n  if (!(sdkBounds1 instanceof SDKLatLngBounds) || !(sdkBounds2 instanceof SDKLatLngBounds)) {\n    return false;\n  }\n\n  return sdkBounds1.ne.lat === sdkBounds2.ne.lat && sdkBounds1.ne.lng === sdkBounds2.ne.lng && sdkBounds1.sw.lat === sdkBounds2.sw.lat && sdkBounds1.sw.lng === sdkBounds2.sw.lng;\n};\n/**\r\n * Calculate a bounding box in the given location\r\n *\r\n * @param {latlng} center - center of the bounding box\r\n * @param {distance} distance - distance in meters from the center to\r\n * the sides of the bounding box\r\n *\r\n * @return {LatLngBounds} bounding box around the given location\r\n *\r\n */\n\nexport const locationBounds = (latlng, distance) => {\n  const bounds = new window.google.maps.Circle({\n    center: new window.google.maps.LatLng(latlng.lat, latlng.lng),\n    radius: distance\n  }).getBounds();\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return new SDKLatLngBounds(new SDKLatLng(ne.lat(), ne.lng()), new SDKLatLng(sw.lat(), sw.lng()));\n};\n/**\r\n * Helper functions for handling Google OverlayView.\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {element} containerElement - map container\r\n * @param {object} props - map props\r\n * @return position offset to allow custom position for the OverlayView\r\n */\n\nexport const getOffsetOverride = (containerElement, props) => {\n  const {\n    getPixelPositionOffset\n  } = props; //\n  // Allows the component to control the visual position of the OverlayView\n  // relative to the LatLng pixel position.\n  //\n\n  if (typeof getPixelPositionOffset === 'function') {\n    return getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight);\n  } else {\n    return {};\n  }\n};\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLngBounds} bounds - map bounds.\r\n *\r\n * @return styles to render the overlay within the projection.\r\n */\n\nconst getLayoutStylesByBounds = (mapCanvasProjection, offset, bounds) => {\n  const ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n  const sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n\n  if (ne && sw) {\n    return {\n      left: `${sw.x + offset.x}px`,\n      top: `${ne.y + offset.y}px`,\n      width: `${ne.x - sw.x - offset.x}px`,\n      height: `${sw.y - ne.y - offset.y}px`\n    };\n  }\n\n  return {\n    left: `-9999px`,\n    top: `-9999px`\n  };\n};\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLng} position - map position/location.\r\n *\r\n * @return  styles to render single coordinate pair within the projection.\r\n */\n\n\nconst getLayoutStylesByPosition = (mapCanvasProjection, offset, position) => {\n  const point = mapCanvasProjection.fromLatLngToDivPixel(position);\n\n  if (point) {\n    const {\n      x,\n      y\n    } = point;\n    return {\n      left: `${x + offset.x}px`,\n      top: `${y + offset.y}px`\n    };\n  }\n\n  return {\n    left: `-9999px`,\n    top: `-9999px`\n  };\n};\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {object} props - map props.\r\n *\r\n * @return styles to render an area or a single coordinate pair within the projection.\r\n */\n\n\nexport const getLayoutStyles = (mapCanvasProjection, offset, props) => {\n  const createLatLng = (inst, Type) => {\n    return new Type(inst.lat, inst.lng);\n  };\n\n  const createLatLngBounds = (inst, Type) => {\n    return new Type(new window.google.maps.LatLng(inst.ne.lat, inst.ne.lng), new window.google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n  };\n\n  const ensureOfType = (inst, type, factory) => {\n    if (inst instanceof type) {\n      return inst;\n    } else {\n      return factory(inst, type);\n    }\n  };\n\n  if (props.bounds) {\n    const bounds = ensureOfType(props.bounds, window.google.maps.LatLngBounds, createLatLngBounds);\n    return getLayoutStylesByBounds(mapCanvasProjection, offset, bounds);\n  } else {\n    const position = ensureOfType(props.position, window.google.maps.LatLng, createLatLng);\n    return getLayoutStylesByPosition(mapCanvasProjection, offset, position);\n  }\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/googleMaps.js"],"names":["types","sdkTypes","LatLng","SDKLatLng","LatLngBounds","SDKLatLngBounds","placeOrigin","place","geometry","location","lat","lng","placeBounds","viewport","ne","getNorthEast","sw","getSouthWest","getPlaceDetails","placeId","sessionToken","Promise","resolve","reject","serviceStatus","window","google","maps","places","PlacesServiceStatus","el","document","createElement","service","PlacesService","fields","sessionTokenMaybe","getDetails","status","OK","Error","address","formatted_address","origin","bounds","predictionSuccessful","ZERO_RESULTS","getPlacePredictions","search","searchConfigurations","AutocompleteService","input","predictions","results","sdkBoundsToFixedCoordinates","sdkBounds","fixedPrecision","fixed","n","Number","parseFloat","toFixed","hasSameSDKBounds","sdkBounds1","sdkBounds2","locationBounds","latlng","distance","Circle","center","radius","getBounds","getOffsetOverride","containerElement","props","getPixelPositionOffset","offsetWidth","offsetHeight","getLayoutStylesByBounds","mapCanvasProjection","offset","fromLatLngToDivPixel","left","x","top","y","width","height","getLayoutStylesByPosition","position","point","getLayoutStyles","createLatLng","inst","Type","createLatLngBounds","ensureOfType","type","factory"],"mappings":"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","sourcesContent":["import { types as sdkTypes } from '../util/sdkLoader';\r\n\r\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\r\n\r\nconst placeOrigin = place => {\r\n  if (place && place.geometry && place.geometry.location) {\r\n    return new SDKLatLng(place.geometry.location.lat(), place.geometry.location.lng());\r\n  }\r\n  return null;\r\n};\r\n\r\nconst placeBounds = place => {\r\n  if (place && place.geometry && place.geometry.viewport) {\r\n    const ne = place.geometry.viewport.getNorthEast();\r\n    const sw = place.geometry.viewport.getSouthWest();\r\n    return new SDKLatLngBounds(\r\n      new SDKLatLng(ne.lat(), ne.lng()),\r\n      new SDKLatLng(sw.lat(), sw.lng())\r\n    );\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Get a detailed place object\r\n *\r\n * @param {String} placeId - ID for a place received from the\r\n * autocomplete service\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n *\r\n * @return {Promise<util.propTypes.place>} Promise that\r\n * resolves to the detailed place, rejects if the request failed\r\n */\r\nexport const getPlaceDetails = (placeId, sessionToken) =>\r\n  new Promise((resolve, reject) => {\r\n    const serviceStatus = window.google.maps.places.PlacesServiceStatus;\r\n    const el = document.createElement('div');\r\n    const service = new window.google.maps.places.PlacesService(el);\r\n    const fields = ['address_component', 'formatted_address', 'geometry', 'place_id'];\r\n    const sessionTokenMaybe = sessionToken ? { sessionToken } : {};\r\n\r\n    service.getDetails({ placeId, fields, ...sessionTokenMaybe }, (place, status) => {\r\n      if (status !== serviceStatus.OK) {\r\n        reject(\r\n          new Error(`Could not get details for place id \"${placeId}\", error status was \"${status}\"`)\r\n        );\r\n      } else {\r\n        resolve({\r\n          address: place.formatted_address,\r\n          origin: placeOrigin(place),\r\n          bounds: placeBounds(place),\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\nconst predictionSuccessful = status => {\r\n  const { OK, ZERO_RESULTS } = window.google.maps.places.PlacesServiceStatus;\r\n  return status === OK || status === ZERO_RESULTS;\r\n};\r\n\r\n/**\r\n * Get place predictions for the given search\r\n *\r\n * @param {String} search - place name or address to search\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n * @param {Object} searchConfigurations - defines the search configurations that can be used with\r\n * the autocomplete service. Used to restrict search to specific country (or countries).\r\n *\r\n * @return {Promise<{ search, predictions[] }>} - Promise of an object\r\n * with the original search query and an array of\r\n * `google.maps.places.AutocompletePrediction` objects\r\n */\r\nexport const getPlacePredictions = (search, sessionToken, searchConfigurations) =>\r\n  new Promise((resolve, reject) => {\r\n    const service = new window.google.maps.places.AutocompleteService();\r\n    const sessionTokenMaybe = sessionToken ? { sessionToken } : {};\r\n\r\n    service.getPlacePredictions(\r\n      { input: search, ...sessionTokenMaybe, ...searchConfigurations },\r\n      (predictions, status) => {\r\n        if (!predictionSuccessful(status)) {\r\n          reject(new Error(`Prediction service status not OK: ${status}`));\r\n        } else {\r\n          const results = {\r\n            search,\r\n            predictions: predictions || [],\r\n          };\r\n          resolve(results);\r\n        }\r\n      }\r\n    );\r\n  });\r\n\r\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Cut some precision from bounds coordinates to tackle subtle map movements\r\n * when map is moved manually\r\n *\r\n * @param {LatLngBounds} sdkBounds - bounds to be changed to fixed precision\r\n * @param {Number} fixedPrecision - integer to be used on tofixed() change.\r\n *\r\n * @return {SDKLatLngBounds} - bounds cut to given fixed precision\r\n */\r\nexport const sdkBoundsToFixedCoordinates = (sdkBounds, fixedPrecision) => {\r\n  const fixed = n => Number.parseFloat(n.toFixed(fixedPrecision));\r\n  const ne = new SDKLatLng(fixed(sdkBounds.ne.lat), fixed(sdkBounds.ne.lng));\r\n  const sw = new SDKLatLng(fixed(sdkBounds.sw.lat), fixed(sdkBounds.sw.lng));\r\n\r\n  return new SDKLatLngBounds(ne, sw);\r\n};\r\n\r\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Check if given bounds object have the same coordinates\r\n *\r\n * @param {LatLngBounds} sdkBounds1 - bounds #1 to be compared\r\n * @param {LatLngBounds} sdkBounds2 - bounds #2 to be compared\r\n *\r\n * @return {boolean} - true if bounds are the same\r\n */\r\nexport const hasSameSDKBounds = (sdkBounds1, sdkBounds2) => {\r\n  if (!(sdkBounds1 instanceof SDKLatLngBounds) || !(sdkBounds2 instanceof SDKLatLngBounds)) {\r\n    return false;\r\n  }\r\n  return (\r\n    sdkBounds1.ne.lat === sdkBounds2.ne.lat &&\r\n    sdkBounds1.ne.lng === sdkBounds2.ne.lng &&\r\n    sdkBounds1.sw.lat === sdkBounds2.sw.lat &&\r\n    sdkBounds1.sw.lng === sdkBounds2.sw.lng\r\n  );\r\n};\r\n\r\n/**\r\n * Calculate a bounding box in the given location\r\n *\r\n * @param {latlng} center - center of the bounding box\r\n * @param {distance} distance - distance in meters from the center to\r\n * the sides of the bounding box\r\n *\r\n * @return {LatLngBounds} bounding box around the given location\r\n *\r\n */\r\nexport const locationBounds = (latlng, distance) => {\r\n  const bounds = new window.google.maps.Circle({\r\n    center: new window.google.maps.LatLng(latlng.lat, latlng.lng),\r\n    radius: distance,\r\n  }).getBounds();\r\n\r\n  const ne = bounds.getNorthEast();\r\n  const sw = bounds.getSouthWest();\r\n\r\n  return new SDKLatLngBounds(new SDKLatLng(ne.lat(), ne.lng()), new SDKLatLng(sw.lat(), sw.lng()));\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView.\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {element} containerElement - map container\r\n * @param {object} props - map props\r\n * @return position offset to allow custom position for the OverlayView\r\n */\r\nexport const getOffsetOverride = (containerElement, props) => {\r\n  const { getPixelPositionOffset } = props;\r\n  //\r\n  // Allows the component to control the visual position of the OverlayView\r\n  // relative to the LatLng pixel position.\r\n  //\r\n  if (typeof getPixelPositionOffset === 'function') {\r\n    return getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight);\r\n  } else {\r\n    return {};\r\n  }\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLngBounds} bounds - map bounds.\r\n *\r\n * @return styles to render the overlay within the projection.\r\n */\r\nconst getLayoutStylesByBounds = (mapCanvasProjection, offset, bounds) => {\r\n  const ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\r\n  const sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\r\n  if (ne && sw) {\r\n    return {\r\n      left: `${sw.x + offset.x}px`,\r\n      top: `${ne.y + offset.y}px`,\r\n      width: `${ne.x - sw.x - offset.x}px`,\r\n      height: `${sw.y - ne.y - offset.y}px`,\r\n    };\r\n  }\r\n  return {\r\n    left: `-9999px`,\r\n    top: `-9999px`,\r\n  };\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLng} position - map position/location.\r\n *\r\n * @return  styles to render single coordinate pair within the projection.\r\n */\r\nconst getLayoutStylesByPosition = (mapCanvasProjection, offset, position) => {\r\n  const point = mapCanvasProjection.fromLatLngToDivPixel(position);\r\n  if (point) {\r\n    const { x, y } = point;\r\n    return {\r\n      left: `${x + offset.x}px`,\r\n      top: `${y + offset.y}px`,\r\n    };\r\n  }\r\n  return {\r\n    left: `-9999px`,\r\n    top: `-9999px`,\r\n  };\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {object} props - map props.\r\n *\r\n * @return styles to render an area or a single coordinate pair within the projection.\r\n */\r\nexport const getLayoutStyles = (mapCanvasProjection, offset, props) => {\r\n  const createLatLng = (inst, Type) => {\r\n    return new Type(inst.lat, inst.lng);\r\n  };\r\n\r\n  const createLatLngBounds = (inst, Type) => {\r\n    return new Type(\r\n      new window.google.maps.LatLng(inst.ne.lat, inst.ne.lng),\r\n      new window.google.maps.LatLng(inst.sw.lat, inst.sw.lng)\r\n    );\r\n  };\r\n\r\n  const ensureOfType = (inst, type, factory) => {\r\n    if (inst instanceof type) {\r\n      return inst;\r\n    } else {\r\n      return factory(inst, type);\r\n    }\r\n  };\r\n\r\n  if (props.bounds) {\r\n    const bounds = ensureOfType(props.bounds, window.google.maps.LatLngBounds, createLatLngBounds);\r\n    return getLayoutStylesByBounds(mapCanvasProjection, offset, bounds);\r\n  } else {\r\n    const position = ensureOfType(props.position, window.google.maps.LatLng, createLatLng);\r\n    return getLayoutStylesByPosition(mapCanvasProjection, offset, position);\r\n  }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}