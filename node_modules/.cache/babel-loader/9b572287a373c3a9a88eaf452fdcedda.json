{"ast":null,"code":"var _jsxFileName = \"D:\\\\Amardeep\\\\tarek_project\\\\ftw-product\\\\src\\\\routing\\\\Routes.js\";\nimport React, { Component } from 'react';\nimport { arrayOf, bool, object, func, shape, string } from 'prop-types';\nimport { compose } from 'redux';\nimport { connect } from 'react-redux';\nimport { Switch, Route, withRouter } from 'react-router-dom';\nimport routeConfiguration from '../routing/routeConfiguration';\nimport { propTypes } from '../util/types';\nimport * as log from '../util/log';\nimport { canonicalRoutePath } from '../util/routes';\nimport { locationChanged } from '../ducks/Routing.duck';\nimport { NamedRedirect } from '../components';\nimport NotFoundPage from '../containers/NotFoundPage/NotFoundPage';\nimport LoadableComponentErrorBoundary from './LoadableComponentErrorBoundary/LoadableComponentErrorBoundary';\n\nconst canShowComponent = props => {\n  const {\n    isAuthenticated,\n    route\n  } = props;\n  const {\n    auth\n  } = route;\n  return !auth || isAuthenticated;\n};\n\nconst callLoadData = props => {\n  const {\n    match,\n    location,\n    route,\n    dispatch,\n    logoutInProgress\n  } = props;\n  const {\n    loadData,\n    name\n  } = route;\n  const shouldLoadData = typeof loadData === 'function' && canShowComponent(props) && !logoutInProgress;\n\n  if (shouldLoadData) {\n    dispatch(loadData(match.params, location.search)).then(() => {\n      // eslint-disable-next-line no-console\n      console.log(`loadData success for ${name} route`);\n    }).catch(e => {\n      log.error(e, 'load-data-failed', {\n        routeName: name\n      });\n    });\n  }\n};\n\nconst setPageScrollPosition = location => {\n  if (!location.hash) {\n    // No hash, scroll to top\n    window.scroll({\n      top: 0,\n      left: 0\n    });\n  } else {\n    const el = document.querySelector(location.hash);\n\n    if (el) {\n      // Found element with the given fragment identifier, scrolling\n      // to that element.\n      //\n      // NOTE: This isn't foolproof. It works when navigating within\n      // the application between pages and within a single page. It\n      // also works with the initial page load. However, it doesn't\n      // seem work work properly when refreshing the page, at least\n      // not in Chrome.\n      //\n      // TODO: investigate why the scrolling fails on refresh\n      el.scrollIntoView({\n        block: 'start',\n        behavior: 'smooth'\n      });\n    }\n  }\n};\n\nconst handleLocationChanged = (dispatch, location) => {\n  setPageScrollPosition(location);\n  const url = canonicalRoutePath(routeConfiguration(), location);\n  dispatch(locationChanged(location, url));\n};\n/**\r\n * RouteComponentRenderer handles loadData calls on client-side.\r\n * It also checks authentication and redirects unauthenticated users\r\n * away from routes that are for authenticated users only\r\n * (aka \"auth: true\" is set in routeConfiguration.js)\r\n *\r\n * This component is a container: it needs to be connected to Redux.\r\n */\n\n\nclass RouteComponentRenderer extends Component {\n  componentDidMount() {\n    // Calling loadData on initial rendering (on client side).\n    callLoadData(this.props);\n    handleLocationChanged(this.props.dispatch, this.props.location);\n  }\n\n  componentDidUpdate(prevProps) {\n    // Call for handleLocationChanged affects store/state\n    // and it generates an unnecessary update.\n    if (prevProps.location !== this.props.location) {\n      // Calling loadData after initial rendering (on client side).\n      // This makes it possible to use loadData as default client side data loading technique.\n      // However it is better to fetch data before location change to avoid \"Loading data\" state.\n      callLoadData(this.props);\n      handleLocationChanged(this.props.dispatch, this.props.location);\n    }\n  }\n\n  render() {\n    const {\n      route,\n      match,\n      location,\n      staticContext\n    } = this.props;\n    const {\n      component: RouteComponent,\n      authPage = 'SignupPage',\n      extraProps\n    } = route;\n    const canShow = canShowComponent(this.props);\n\n    if (!canShow) {\n      staticContext.unauthorized = true;\n    }\n\n    return canShow ? /*#__PURE__*/React.createElement(LoadableComponentErrorBoundary, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(RouteComponent, Object.assign({\n      params: match.params,\n      location: location\n    }, extraProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 112,\n        columnNumber: 9\n      }\n    }))) : /*#__PURE__*/React.createElement(NamedRedirect, {\n      name: authPage,\n      state: {\n        from: `${location.pathname}${location.search}${location.hash}`\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 115,\n        columnNumber: 7\n      }\n    });\n  }\n\n}\n\nRouteComponentRenderer.defaultProps = {\n  staticContext: {}\n};\nRouteComponentRenderer.propTypes = {\n  isAuthenticated: bool.isRequired,\n  logoutInProgress: bool.isRequired,\n  route: propTypes.route.isRequired,\n  match: shape({\n    params: object.isRequired,\n    url: string.isRequired\n  }).isRequired,\n  location: shape({\n    search: string.isRequired\n  }).isRequired,\n  staticContext: object,\n  dispatch: func.isRequired\n};\n\nconst mapStateToProps = state => {\n  const {\n    isAuthenticated,\n    logoutInProgress\n  } = state.Auth;\n  return {\n    isAuthenticated,\n    logoutInProgress\n  };\n};\n\nconst RouteComponentContainer = compose(connect(mapStateToProps))(RouteComponentRenderer);\n/**\r\n * Routes component creates React Router rendering setup.\r\n * It needs routeConfiguration (named as \"routes\") through props.\r\n * Using that configuration it creates navigation on top of page-level\r\n * components. Essentially, it's something like:\r\n * <Switch>\r\n *   <Route render={pageA} />\r\n *   <Route render={pageB} />\r\n * </Switch>\r\n */\n\nconst Routes = (props, context) => {\n  const {\n    isAuthenticated,\n    logoutInProgress,\n    routes\n  } = props;\n\n  const toRouteComponent = route => {\n    const renderProps = {\n      isAuthenticated,\n      logoutInProgress,\n      route\n    }; // By default, our routes are exact.\n    // https://reacttraining.com/react-router/web/api/Route/exact-bool\n\n    const isExact = route.exact != null ? route.exact : true;\n    return /*#__PURE__*/React.createElement(Route, {\n      key: route.name,\n      path: route.path,\n      exact: isExact,\n      render: matchProps => /*#__PURE__*/React.createElement(RouteComponentContainer, Object.assign({}, renderProps, {\n        match: matchProps.match,\n        location: matchProps.location,\n        staticContext: matchProps.staticContext,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 175,\n          columnNumber: 11\n        }\n      })),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 170,\n        columnNumber: 7\n      }\n    });\n  }; // N.B. routes prop within React Router needs to stay the same,\n  // so that React is is not rerendering page component.\n  // That's why we pass-in props.routes instead of calling routeConfiguration here.\n\n\n  return /*#__PURE__*/React.createElement(Switch, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 5\n    }\n  }, routes.map(toRouteComponent), /*#__PURE__*/React.createElement(Route, {\n    component: NotFoundPage,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 192,\n      columnNumber: 7\n    }\n  }));\n};\n\n_c = Routes;\nRoutes.propTypes = {\n  routes: arrayOf(propTypes.route).isRequired\n};\nexport default _c2 = withRouter(Routes);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Routes\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/routing/Routes.js"],"names":["React","Component","arrayOf","bool","object","func","shape","string","compose","connect","Switch","Route","withRouter","routeConfiguration","propTypes","log","canonicalRoutePath","locationChanged","NamedRedirect","NotFoundPage","LoadableComponentErrorBoundary","canShowComponent","props","isAuthenticated","route","auth","callLoadData","match","location","dispatch","logoutInProgress","loadData","name","shouldLoadData","params","search","then","console","catch","e","error","routeName","setPageScrollPosition","hash","window","scroll","top","left","el","document","querySelector","scrollIntoView","block","behavior","handleLocationChanged","url","RouteComponentRenderer","componentDidMount","componentDidUpdate","prevProps","render","staticContext","component","RouteComponent","authPage","extraProps","canShow","unauthorized","from","pathname","defaultProps","isRequired","mapStateToProps","state","Auth","RouteComponentContainer","Routes","context","routes","toRouteComponent","renderProps","isExact","exact","path","matchProps","map"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport { arrayOf, bool, object, func, shape, string } from 'prop-types';\r\nimport { compose } from 'redux';\r\nimport { connect } from 'react-redux';\r\nimport { Switch, Route, withRouter } from 'react-router-dom';\r\n\r\nimport routeConfiguration from '../routing/routeConfiguration';\r\nimport { propTypes } from '../util/types';\r\nimport * as log from '../util/log';\r\nimport { canonicalRoutePath } from '../util/routes';\r\nimport { locationChanged } from '../ducks/Routing.duck';\r\n\r\nimport { NamedRedirect } from '../components';\r\nimport NotFoundPage from '../containers/NotFoundPage/NotFoundPage';\r\n\r\nimport LoadableComponentErrorBoundary from './LoadableComponentErrorBoundary/LoadableComponentErrorBoundary';\r\n\r\nconst canShowComponent = props => {\r\n  const { isAuthenticated, route } = props;\r\n  const { auth } = route;\r\n  return !auth || isAuthenticated;\r\n};\r\n\r\nconst callLoadData = props => {\r\n  const { match, location, route, dispatch, logoutInProgress } = props;\r\n  const { loadData, name } = route;\r\n  const shouldLoadData =\r\n    typeof loadData === 'function' && canShowComponent(props) && !logoutInProgress;\r\n\r\n  if (shouldLoadData) {\r\n    dispatch(loadData(match.params, location.search))\r\n      .then(() => {\r\n        // eslint-disable-next-line no-console\r\n        console.log(`loadData success for ${name} route`);\r\n      })\r\n      .catch(e => {\r\n        log.error(e, 'load-data-failed', { routeName: name });\r\n      });\r\n  }\r\n};\r\n\r\nconst setPageScrollPosition = location => {\r\n  if (!location.hash) {\r\n    // No hash, scroll to top\r\n    window.scroll({\r\n      top: 0,\r\n      left: 0,\r\n    });\r\n  } else {\r\n    const el = document.querySelector(location.hash);\r\n    if (el) {\r\n      // Found element with the given fragment identifier, scrolling\r\n      // to that element.\r\n      //\r\n      // NOTE: This isn't foolproof. It works when navigating within\r\n      // the application between pages and within a single page. It\r\n      // also works with the initial page load. However, it doesn't\r\n      // seem work work properly when refreshing the page, at least\r\n      // not in Chrome.\r\n      //\r\n      // TODO: investigate why the scrolling fails on refresh\r\n      el.scrollIntoView({\r\n        block: 'start',\r\n        behavior: 'smooth',\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst handleLocationChanged = (dispatch, location) => {\r\n  setPageScrollPosition(location);\r\n  const url = canonicalRoutePath(routeConfiguration(), location);\r\n  dispatch(locationChanged(location, url));\r\n};\r\n\r\n/**\r\n * RouteComponentRenderer handles loadData calls on client-side.\r\n * It also checks authentication and redirects unauthenticated users\r\n * away from routes that are for authenticated users only\r\n * (aka \"auth: true\" is set in routeConfiguration.js)\r\n *\r\n * This component is a container: it needs to be connected to Redux.\r\n */\r\nclass RouteComponentRenderer extends Component {\r\n  componentDidMount() {\r\n    // Calling loadData on initial rendering (on client side).\r\n    callLoadData(this.props);\r\n    handleLocationChanged(this.props.dispatch, this.props.location);\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    // Call for handleLocationChanged affects store/state\r\n    // and it generates an unnecessary update.\r\n    if (prevProps.location !== this.props.location) {\r\n      // Calling loadData after initial rendering (on client side).\r\n      // This makes it possible to use loadData as default client side data loading technique.\r\n      // However it is better to fetch data before location change to avoid \"Loading data\" state.\r\n      callLoadData(this.props);\r\n      handleLocationChanged(this.props.dispatch, this.props.location);\r\n    }\r\n  }\r\n\r\n  render() {\r\n    const { route, match, location, staticContext } = this.props;\r\n    const { component: RouteComponent, authPage = 'SignupPage', extraProps } = route;\r\n    const canShow = canShowComponent(this.props);\r\n    if (!canShow) {\r\n      staticContext.unauthorized = true;\r\n    }\r\n    return canShow ? (\r\n      <LoadableComponentErrorBoundary>\r\n        <RouteComponent params={match.params} location={location} {...extraProps} />\r\n      </LoadableComponentErrorBoundary>\r\n    ) : (\r\n      <NamedRedirect\r\n        name={authPage}\r\n        state={{ from: `${location.pathname}${location.search}${location.hash}` }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nRouteComponentRenderer.defaultProps = { staticContext: {} };\r\n\r\nRouteComponentRenderer.propTypes = {\r\n  isAuthenticated: bool.isRequired,\r\n  logoutInProgress: bool.isRequired,\r\n  route: propTypes.route.isRequired,\r\n  match: shape({\r\n    params: object.isRequired,\r\n    url: string.isRequired,\r\n  }).isRequired,\r\n  location: shape({\r\n    search: string.isRequired,\r\n  }).isRequired,\r\n  staticContext: object,\r\n  dispatch: func.isRequired,\r\n};\r\n\r\nconst mapStateToProps = state => {\r\n  const { isAuthenticated, logoutInProgress } = state.Auth;\r\n  return { isAuthenticated, logoutInProgress };\r\n};\r\nconst RouteComponentContainer = compose(connect(mapStateToProps))(RouteComponentRenderer);\r\n\r\n/**\r\n * Routes component creates React Router rendering setup.\r\n * It needs routeConfiguration (named as \"routes\") through props.\r\n * Using that configuration it creates navigation on top of page-level\r\n * components. Essentially, it's something like:\r\n * <Switch>\r\n *   <Route render={pageA} />\r\n *   <Route render={pageB} />\r\n * </Switch>\r\n */\r\nconst Routes = (props, context) => {\r\n  const { isAuthenticated, logoutInProgress, routes } = props;\r\n\r\n  const toRouteComponent = route => {\r\n    const renderProps = {\r\n      isAuthenticated,\r\n      logoutInProgress,\r\n      route,\r\n    };\r\n\r\n    // By default, our routes are exact.\r\n    // https://reacttraining.com/react-router/web/api/Route/exact-bool\r\n    const isExact = route.exact != null ? route.exact : true;\r\n    return (\r\n      <Route\r\n        key={route.name}\r\n        path={route.path}\r\n        exact={isExact}\r\n        render={matchProps => (\r\n          <RouteComponentContainer\r\n            {...renderProps}\r\n            match={matchProps.match}\r\n            location={matchProps.location}\r\n            staticContext={matchProps.staticContext}\r\n          />\r\n        )}\r\n      />\r\n    );\r\n  };\r\n\r\n  // N.B. routes prop within React Router needs to stay the same,\r\n  // so that React is is not rerendering page component.\r\n  // That's why we pass-in props.routes instead of calling routeConfiguration here.\r\n  return (\r\n    <Switch>\r\n      {routes.map(toRouteComponent)}\r\n      <Route component={NotFoundPage} />\r\n    </Switch>\r\n  );\r\n};\r\n\r\nRoutes.propTypes = {\r\n  routes: arrayOf(propTypes.route).isRequired,\r\n};\r\n\r\nexport default withRouter(Routes);\r\n"]},"metadata":{},"sourceType":"module"}