{"ast":null,"code":"var _jsxFileName = \"D:\\\\Amardeep\\\\tarek_project\\\\ftw-product\\\\src\\\\util\\\\richText.js\";\nimport React from 'react';\nimport flow from 'lodash/flow';\nimport flatMap from 'lodash/flatMap';\nimport map from 'lodash/map';\nimport { ExternalLink } from '../components';\n/**\r\n * Add zero width space (zwsp) around given breakchars (default '/') to make word break possible.\r\n * E.g. \"one/two/three\" => [\"one\", \"​/​\", \"two\" \"​/​\" \"three\"]\r\n *\r\n * @param {string} wordToBreak word to be broken from special character points.\r\n * @param {string} breakChars string containing possible chars that can be surrounded with zwsp.\r\n * @return {Array<string>} returns an array containing strings-\r\n */\n\nexport const zwspAroundSpecialCharsSplit = (wordToBreak, breakChars = '/') => {\n  if (typeof wordToBreak !== 'string') {\n    return wordToBreak;\n  }\n\n  const bcArray = breakChars.split(''); // Escape special regular expression chars\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\n  const escapedBCArray = bcArray.map(c => c.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\n  const reSplit = new RegExp('([' + escapedBCArray.join('') + '])');\n  const zwsp = '​';\n  return wordToBreak.split(reSplit).map(w => bcArray.includes(w) ? `${zwsp}${w}${zwsp}` : w);\n};\n/**\r\n * Layouts are not fixed sizes - So, long words in text make flexboxed items to grow too big.\r\n * This wraps long words with span and adds given class to it\r\n *\r\n * @param {string} word to be wrapped if requirement (longWordMinLength) is met\r\n * @param {number} key span needs a key in React/JSX\r\n * @param {number} longWordMinLength minimum length when word is considered long\r\n * @param {string} longWordClass class to be added to spans\r\n * @return {node} returns a string or component\r\n */\n\nexport const wrapLongWord = (word, key, options = {}) => {\n  const {\n    longWordMinLength,\n    longWordClass\n  } = options;\n\n  if (typeof word !== 'string' || !(longWordMinLength && longWordClass)) {\n    return word;\n  }\n\n  const isShortWord = word.length <= longWordMinLength;\n  return isShortWord ? word : /*#__PURE__*/React.createElement(\"span\", {\n    key: key,\n    className: longWordClass,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 5\n    }\n  }, word);\n};\n/**\r\n * Find links from words and surround them with <ExternalLink> component\r\n *\r\n * @param {string} word to be linkified if requirement (link) is met\r\n * @param {number} key span needs a key in React/JSX\r\n * @param {Object} options than can contain keys: linkify, linkClass.\r\n * @return {Array<node>} returns a array containing ExternalLink component or strings\r\n */\n\nexport const linkifyOrWrapLinkSplit = (word, key, options = {}) => {\n  if (typeof word !== 'string') {\n    return word;\n  }\n\n  const {\n    linkify,\n    linkClass\n  } = options; // TODO This can't handle links that contain parenthesis:\n  // '(http://example.org/path_(etc))'\n  // Currently extracts:\n  // '(<a href=\\\"http://example.org/path_\\\" ...>http://example.org/path_</a>(etc))'\n  //\n  // We need to\n  // 1) track whether token before link contains parenthesis as a last character\n  //    before link token (\"word.split(urlRegex)[linkIndex - 1]\") and\n  // 2) add enough characters to the end of link-token from the next token\n  //    after link (\"word.split(urlRegex)[linkIndex + 1]\")\n  // urlRegex modified from examples in\n  // https://stackoverflow.com/questions/1500260/detect-urls-in-text-with-javascript\n  // eslint-disable-next-line no-useless-escape\n\n  const urlRegex = /(\\bhttps?:\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/gi;\n\n  if (word.match(urlRegex)) {\n    // Split strings like \"(http://www.example.com)\" to [\"(\",\"http://www.example.com\",\")\"]\n    return word.split(urlRegex).map(w => {\n      return !w.match(urlRegex) ? w : linkify ? /*#__PURE__*/React.createElement(ExternalLink, {\n        key: key,\n        href: w,\n        className: linkClass,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 93,\n          columnNumber: 9\n        }\n      }, w) : linkClass ? /*#__PURE__*/React.createElement(\"span\", {\n        key: key,\n        className: linkClass,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 97,\n          columnNumber: 9\n        }\n      }, w) : w;\n    });\n  } else {\n    return word;\n  }\n};\n/**\r\n * Scan text to fill in wrappers for long words and add links.\r\n * Wrap long words: options should contain longWordMinLength & longWordClass\r\n * Linkify found links: options should contain \"linkify: true\" (linkClass is optional)\r\n *\r\n * @param {string} text check text content\r\n * @param {object} options { longWordMinLength, longWordClass, linkify = false, linkClass }\r\n * @return {Array<node>} returns a child array containing strings and inline elements\r\n */\n\nexport const richText = (text, options) => {\n  if (typeof text !== 'string') {\n    return text;\n  } // longWordMinLength & longWordClass are needed for long words to be spanned\n  // linkify = true is needed for links to be linkified (linkClass is optional)\n\n\n  const {\n    longWordMinLength,\n    longWordClass,\n    linkify = false,\n    linkClass\n  } = options;\n  const linkOrLongWordClass = linkClass ? linkClass : longWordClass;\n  const nonWhiteSpaceSequence = /([^\\s]+)/gi;\n  return text.split(nonWhiteSpaceSequence).reduce((acc, nextChild, i) => {\n    const parts = flow([v => flatMap(v, w => linkifyOrWrapLinkSplit(w, i, {\n      linkify,\n      linkClass: linkOrLongWordClass\n    })), v => flatMap(v, w => zwspAroundSpecialCharsSplit(w, '/,')), v => map(v, (w, j) => wrapLongWord(w, `${i}${j}`, {\n      longWordMinLength,\n      longWordClass\n    }))])([nextChild]);\n    return acc.concat(parts);\n  }, []);\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/richText.js"],"names":["React","flow","flatMap","map","ExternalLink","zwspAroundSpecialCharsSplit","wordToBreak","breakChars","bcArray","split","escapedBCArray","c","replace","reSplit","RegExp","join","zwsp","w","includes","wrapLongWord","word","key","options","longWordMinLength","longWordClass","isShortWord","length","linkifyOrWrapLinkSplit","linkify","linkClass","urlRegex","match","richText","text","linkOrLongWordClass","nonWhiteSpaceSequence","reduce","acc","nextChild","i","parts","v","j","concat"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport flow from 'lodash/flow';\r\nimport flatMap from 'lodash/flatMap';\r\nimport map from 'lodash/map';\r\nimport { ExternalLink } from '../components';\r\n\r\n/**\r\n * Add zero width space (zwsp) around given breakchars (default '/') to make word break possible.\r\n * E.g. \"one/two/three\" => [\"one\", \"​/​\", \"two\" \"​/​\" \"three\"]\r\n *\r\n * @param {string} wordToBreak word to be broken from special character points.\r\n * @param {string} breakChars string containing possible chars that can be surrounded with zwsp.\r\n * @return {Array<string>} returns an array containing strings-\r\n */\r\nexport const zwspAroundSpecialCharsSplit = (wordToBreak, breakChars = '/') => {\r\n  if (typeof wordToBreak !== 'string') {\r\n    return wordToBreak;\r\n  }\r\n\r\n  const bcArray = breakChars.split('');\r\n\r\n  // Escape special regular expression chars\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\r\n  const escapedBCArray = bcArray.map(c => c.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'));\r\n  const reSplit = new RegExp('([' + escapedBCArray.join('') + '])');\r\n\r\n  const zwsp = '​';\r\n  return wordToBreak.split(reSplit).map(w => (bcArray.includes(w) ? `${zwsp}${w}${zwsp}` : w));\r\n};\r\n\r\n/**\r\n * Layouts are not fixed sizes - So, long words in text make flexboxed items to grow too big.\r\n * This wraps long words with span and adds given class to it\r\n *\r\n * @param {string} word to be wrapped if requirement (longWordMinLength) is met\r\n * @param {number} key span needs a key in React/JSX\r\n * @param {number} longWordMinLength minimum length when word is considered long\r\n * @param {string} longWordClass class to be added to spans\r\n * @return {node} returns a string or component\r\n */\r\nexport const wrapLongWord = (word, key, options = {}) => {\r\n  const { longWordMinLength, longWordClass } = options;\r\n  if (typeof word !== 'string' || !(longWordMinLength && longWordClass)) {\r\n    return word;\r\n  }\r\n\r\n  const isShortWord = word.length <= longWordMinLength;\r\n  return isShortWord ? (\r\n    word\r\n  ) : (\r\n    <span key={key} className={longWordClass}>\r\n      {word}\r\n    </span>\r\n  );\r\n};\r\n\r\n/**\r\n * Find links from words and surround them with <ExternalLink> component\r\n *\r\n * @param {string} word to be linkified if requirement (link) is met\r\n * @param {number} key span needs a key in React/JSX\r\n * @param {Object} options than can contain keys: linkify, linkClass.\r\n * @return {Array<node>} returns a array containing ExternalLink component or strings\r\n */\r\nexport const linkifyOrWrapLinkSplit = (word, key, options = {}) => {\r\n  if (typeof word !== 'string') {\r\n    return word;\r\n  }\r\n  const { linkify, linkClass } = options;\r\n\r\n  // TODO This can't handle links that contain parenthesis:\r\n  // '(http://example.org/path_(etc))'\r\n  // Currently extracts:\r\n  // '(<a href=\\\"http://example.org/path_\\\" ...>http://example.org/path_</a>(etc))'\r\n  //\r\n  // We need to\r\n  // 1) track whether token before link contains parenthesis as a last character\r\n  //    before link token (\"word.split(urlRegex)[linkIndex - 1]\") and\r\n  // 2) add enough characters to the end of link-token from the next token\r\n  //    after link (\"word.split(urlRegex)[linkIndex + 1]\")\r\n\r\n  // urlRegex modified from examples in\r\n  // https://stackoverflow.com/questions/1500260/detect-urls-in-text-with-javascript\r\n\r\n  // eslint-disable-next-line no-useless-escape\r\n  const urlRegex = /(\\bhttps?:\\/\\/[-A-Z0-9+&@#\\/%?=~_|!:,.;]*[-A-Z0-9+&@#\\/%=~_|])/gi;\r\n  if (word.match(urlRegex)) {\r\n    // Split strings like \"(http://www.example.com)\" to [\"(\",\"http://www.example.com\",\")\"]\r\n    return word.split(urlRegex).map(w => {\r\n      return !w.match(urlRegex) ? (\r\n        w\r\n      ) : linkify ? (\r\n        <ExternalLink key={key} href={w} className={linkClass}>\r\n          {w}\r\n        </ExternalLink>\r\n      ) : linkClass ? (\r\n        <span key={key} className={linkClass}>\r\n          {w}\r\n        </span>\r\n      ) : (\r\n        w\r\n      );\r\n    });\r\n  } else {\r\n    return word;\r\n  }\r\n};\r\n\r\n/**\r\n * Scan text to fill in wrappers for long words and add links.\r\n * Wrap long words: options should contain longWordMinLength & longWordClass\r\n * Linkify found links: options should contain \"linkify: true\" (linkClass is optional)\r\n *\r\n * @param {string} text check text content\r\n * @param {object} options { longWordMinLength, longWordClass, linkify = false, linkClass }\r\n * @return {Array<node>} returns a child array containing strings and inline elements\r\n */\r\nexport const richText = (text, options) => {\r\n  if (typeof text !== 'string') {\r\n    return text;\r\n  }\r\n\r\n  // longWordMinLength & longWordClass are needed for long words to be spanned\r\n  // linkify = true is needed for links to be linkified (linkClass is optional)\r\n  const { longWordMinLength, longWordClass, linkify = false, linkClass } = options;\r\n  const linkOrLongWordClass = linkClass ? linkClass : longWordClass;\r\n  const nonWhiteSpaceSequence = /([^\\s]+)/gi;\r\n\r\n  return text.split(nonWhiteSpaceSequence).reduce((acc, nextChild, i) => {\r\n    const parts = flow([\r\n      v =>\r\n        flatMap(v, w => linkifyOrWrapLinkSplit(w, i, { linkify, linkClass: linkOrLongWordClass })),\r\n      v => flatMap(v, w => zwspAroundSpecialCharsSplit(w, '/,')),\r\n      v => map(v, (w, j) => wrapLongWord(w, `${i}${j}`, { longWordMinLength, longWordClass })),\r\n    ])([nextChild]);\r\n    return acc.concat(parts);\r\n  }, []);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}