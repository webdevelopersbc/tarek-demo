{"ast":null,"code":"import memoize from 'lodash/memoize';\nimport seedrandom from 'seedrandom';\nimport { types as sdkTypes } from './sdkLoader';\nimport config from '../config';\nconst {\n  LatLng,\n  LatLngBounds\n} = sdkTypes;\nconst EARTH_RADIUS = 6371000;\n/* meters  */\n\nconst DEG_TO_RAD = Math.PI / 180.0;\nconst THREE_PI = Math.PI * 3;\nconst TWO_PI = Math.PI * 2;\n\nconst degToRadians = latlng => {\n  const {\n    lat,\n    lng\n  } = latlng;\n  const latR = lat * DEG_TO_RAD;\n  const lngR = lng * DEG_TO_RAD;\n  return {\n    lat: latR,\n    lng: lngR\n  };\n};\n\nconst radToDegrees = latlngInRadians => {\n  const {\n    lat: latR,\n    lng: lngR\n  } = latlngInRadians;\n  const lat = latR / DEG_TO_RAD;\n  const lng = lngR / DEG_TO_RAD;\n  return {\n    lat,\n    lng\n  };\n};\n/**\r\n * This obfuscatedCoordinatesImpl function is a temporary solution for the coordinate obfuscation.\r\n * In the future, improved version needs to have protectedData working and\r\n * available in accepted transaction.\r\n *\r\n * Based on:\r\n * https://gis.stackexchange.com/questions/25877/generating-random-locations-nearby#answer-213898\r\n */\n\n\nconst obfuscatedCoordinatesImpl = (latlng, cacheKey) => {\n  const {\n    lat,\n    lng\n  } = degToRadians(latlng);\n  const sinLat = Math.sin(lat);\n  const cosLat = Math.cos(lat);\n  const randomizeBearing = cacheKey ? seedrandom(cacheKey)() : Math.random();\n  const randomizeDistance = cacheKey ? seedrandom(cacheKey.split('').reverse().join(''))() : Math.random(); // Randomize distance and bearing\n\n  const distance = randomizeDistance * config.maps.fuzzy.offset;\n  const bearing = randomizeBearing * TWO_PI;\n  const theta = distance / EARTH_RADIUS;\n  const sinBearing = Math.sin(bearing);\n  const cosBearing = Math.cos(bearing);\n  const sinTheta = Math.sin(theta);\n  const cosTheta = Math.cos(theta);\n  const newLat = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);\n  const newLng = lng + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(newLat)); // Normalize -PI -> +PI radians\n\n  const newLngNormalized = (newLng + THREE_PI) % TWO_PI - Math.PI;\n  const result = radToDegrees({\n    lat: newLat,\n    lng: newLngNormalized\n  });\n  return new LatLng(result.lat, result.lng);\n};\n\nconst obfuscationKeyGetter = (latlng, cacheKey) => cacheKey;\n\nconst memoizedObfuscatedCoordinatesImpl = memoize(obfuscatedCoordinatesImpl, obfuscationKeyGetter);\n/**\r\n * Make the given coordinates randomly a little bit different.\r\n *\r\n * @param {LatLng} latlng coordinates\r\n * @param {String?} cacheKey if given, the results are memoized and\r\n * the same coordinates are returned for the same key as long as the\r\n * cache isn't cleared (e.g. with page refresh). This results in\r\n * e.g. same listings always getting the same obfuscated coordinates\r\n * if the listing id is used as the cache key.\r\n *\r\n * @return {LatLng} obfuscated coordinates\r\n */\n\nexport const obfuscatedCoordinates = (latlng, cacheKey = null) => {\n  return cacheKey ? memoizedObfuscatedCoordinatesImpl(latlng, cacheKey) : obfuscatedCoordinatesImpl(latlng);\n};\n/**\r\n * Query the user's current location from the browser API\r\n *\r\n * @return {Promise<LatLng>} user's current location\r\n */\n\nexport const userLocation = () => new Promise((resolve, reject) => {\n  const geolocationAvailable = ('geolocation' in navigator);\n\n  if (!geolocationAvailable) {\n    reject(new Error('Geolocation not available in browser'));\n    return;\n  } // Some defaults for user's current geolocation call\n  // https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition\n  // Note: without high accuracy, the given location might differ quite much.\n  //       We decided that true would be better default for a template app.\n\n\n  const options = {\n    enableHighAccuracy: true,\n    timeout: 5000,\n    maximumAge: 0\n  };\n\n  const onSuccess = position => resolve(new LatLng(position.coords.latitude, position.coords.longitude));\n\n  const onError = error => reject(error);\n\n  navigator.geolocation.getCurrentPosition(onSuccess, onError, options);\n});\n/**\r\n * Calculate a circular polyline around the given point\r\n *\r\n * See: https://stackoverflow.com/questions/7316963/drawing-a-circle-google-static-maps\r\n *\r\n * @param {LatLng} latlng - center of the circle\r\n * @param {Number} radius - radius of the circle\r\n *\r\n * @return {Array<Array<Number>>} array of `[lat, lng]` coordinate\r\n * pairs forming the circle\r\n */\n\nexport const circlePolyline = (latlng, radius) => {\n  const {\n    lat,\n    lng\n  } = latlng;\n  const detail = 8;\n  const R = 6371;\n  const pi = Math.PI;\n\n  const _lat = lat * pi / 180;\n\n  const _lng = lng * pi / 180;\n\n  const d = radius / 1000 / R;\n  let points = [];\n\n  for (let i = 0; i <= 360; i += detail) {\n    const brng = i * pi / 180;\n    let pLat = Math.asin(Math.sin(_lat) * Math.cos(d) + Math.cos(_lat) * Math.sin(d) * Math.cos(brng));\n    const pLng = (_lng + Math.atan2(Math.sin(brng) * Math.sin(d) * Math.cos(_lat), Math.cos(d) - Math.sin(_lat) * Math.sin(pLat))) * 180 / pi;\n    pLat = pLat * 180 / pi;\n    points.push([pLat, pLng]);\n  }\n\n  return points;\n};\n/**\r\n * Cut some precision from bounds coordinates to tackle subtle map movements\r\n * when map is moved manually\r\n *\r\n * @param {LatLngBounds} sdkBounds - bounds to be changed to fixed precision\r\n * @param {Number} fixedPrecision - integer to be used on tofixed() change.\r\n *\r\n * @return {LatLngBounds} - bounds cut to given fixed precision\r\n */\n\nexport const sdkBoundsToFixedCoordinates = (sdkBounds, fixedPrecision) => {\n  const fixed = n => Number.parseFloat(n.toFixed(fixedPrecision));\n\n  const ne = new LatLng(fixed(sdkBounds.ne.lat), fixed(sdkBounds.ne.lng));\n  const sw = new LatLng(fixed(sdkBounds.sw.lat), fixed(sdkBounds.sw.lng));\n  return new LatLngBounds(ne, sw);\n};\n/**\r\n * Check if given bounds object have the same coordinates\r\n *\r\n * @param {LatLngBounds} sdkBounds1 - bounds #1 to be compared\r\n * @param {LatLngBounds} sdkBounds2 - bounds #2 to be compared\r\n *\r\n * @return {boolean} - true if bounds are the same\r\n */\n\nexport const hasSameSDKBounds = (sdkBounds1, sdkBounds2) => {\n  if (!(sdkBounds1 instanceof LatLngBounds) || !(sdkBounds2 instanceof LatLngBounds)) {\n    return false;\n  }\n\n  return sdkBounds1.ne.lat === sdkBounds2.ne.lat && sdkBounds1.ne.lng === sdkBounds2.ne.lng && sdkBounds1.sw.lat === sdkBounds2.sw.lat && sdkBounds1.sw.lng === sdkBounds2.sw.lng;\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/maps.js"],"names":["memoize","seedrandom","types","sdkTypes","config","LatLng","LatLngBounds","EARTH_RADIUS","DEG_TO_RAD","Math","PI","THREE_PI","TWO_PI","degToRadians","latlng","lat","lng","latR","lngR","radToDegrees","latlngInRadians","obfuscatedCoordinatesImpl","cacheKey","sinLat","sin","cosLat","cos","randomizeBearing","random","randomizeDistance","split","reverse","join","distance","maps","fuzzy","offset","bearing","theta","sinBearing","cosBearing","sinTheta","cosTheta","newLat","asin","newLng","atan2","newLngNormalized","result","obfuscationKeyGetter","memoizedObfuscatedCoordinatesImpl","obfuscatedCoordinates","userLocation","Promise","resolve","reject","geolocationAvailable","navigator","Error","options","enableHighAccuracy","timeout","maximumAge","onSuccess","position","coords","latitude","longitude","onError","error","geolocation","getCurrentPosition","circlePolyline","radius","detail","R","pi","_lat","_lng","d","points","i","brng","pLat","pLng","push","sdkBoundsToFixedCoordinates","sdkBounds","fixedPrecision","fixed","n","Number","parseFloat","toFixed","ne","sw","hasSameSDKBounds","sdkBounds1","sdkBounds2"],"mappings":"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","sourcesContent":["import memoize from 'lodash/memoize';\r\nimport seedrandom from 'seedrandom';\r\nimport { types as sdkTypes } from './sdkLoader';\r\nimport config from '../config';\r\n\r\nconst { LatLng, LatLngBounds } = sdkTypes;\r\n\r\nconst EARTH_RADIUS = 6371000; /* meters  */\r\nconst DEG_TO_RAD = Math.PI / 180.0;\r\nconst THREE_PI = Math.PI * 3;\r\nconst TWO_PI = Math.PI * 2;\r\n\r\nconst degToRadians = latlng => {\r\n  const { lat, lng } = latlng;\r\n  const latR = lat * DEG_TO_RAD;\r\n  const lngR = lng * DEG_TO_RAD;\r\n  return { lat: latR, lng: lngR };\r\n};\r\n\r\nconst radToDegrees = latlngInRadians => {\r\n  const { lat: latR, lng: lngR } = latlngInRadians;\r\n  const lat = latR / DEG_TO_RAD;\r\n  const lng = lngR / DEG_TO_RAD;\r\n  return { lat, lng };\r\n};\r\n\r\n/**\r\n * This obfuscatedCoordinatesImpl function is a temporary solution for the coordinate obfuscation.\r\n * In the future, improved version needs to have protectedData working and\r\n * available in accepted transaction.\r\n *\r\n * Based on:\r\n * https://gis.stackexchange.com/questions/25877/generating-random-locations-nearby#answer-213898\r\n */\r\n\r\nconst obfuscatedCoordinatesImpl = (latlng, cacheKey) => {\r\n  const { lat, lng } = degToRadians(latlng);\r\n  const sinLat = Math.sin(lat);\r\n  const cosLat = Math.cos(lat);\r\n\r\n  const randomizeBearing = cacheKey ? seedrandom(cacheKey)() : Math.random();\r\n  const randomizeDistance = cacheKey\r\n    ? seedrandom(\r\n        cacheKey\r\n          .split('')\r\n          .reverse()\r\n          .join('')\r\n      )()\r\n    : Math.random();\r\n\r\n  // Randomize distance and bearing\r\n  const distance = randomizeDistance * config.maps.fuzzy.offset;\r\n  const bearing = randomizeBearing * TWO_PI;\r\n  const theta = distance / EARTH_RADIUS;\r\n  const sinBearing = Math.sin(bearing);\r\n  const cosBearing = Math.cos(bearing);\r\n  const sinTheta = Math.sin(theta);\r\n  const cosTheta = Math.cos(theta);\r\n\r\n  const newLat = Math.asin(sinLat * cosTheta + cosLat * sinTheta * cosBearing);\r\n  const newLng =\r\n    lng + Math.atan2(sinBearing * sinTheta * cosLat, cosTheta - sinLat * Math.sin(newLat));\r\n\r\n  // Normalize -PI -> +PI radians\r\n  const newLngNormalized = ((newLng + THREE_PI) % TWO_PI) - Math.PI;\r\n\r\n  const result = radToDegrees({ lat: newLat, lng: newLngNormalized });\r\n  return new LatLng(result.lat, result.lng);\r\n};\r\n\r\nconst obfuscationKeyGetter = (latlng, cacheKey) => cacheKey;\r\n\r\nconst memoizedObfuscatedCoordinatesImpl = memoize(obfuscatedCoordinatesImpl, obfuscationKeyGetter);\r\n\r\n/**\r\n * Make the given coordinates randomly a little bit different.\r\n *\r\n * @param {LatLng} latlng coordinates\r\n * @param {String?} cacheKey if given, the results are memoized and\r\n * the same coordinates are returned for the same key as long as the\r\n * cache isn't cleared (e.g. with page refresh). This results in\r\n * e.g. same listings always getting the same obfuscated coordinates\r\n * if the listing id is used as the cache key.\r\n *\r\n * @return {LatLng} obfuscated coordinates\r\n */\r\nexport const obfuscatedCoordinates = (latlng, cacheKey = null) => {\r\n  return cacheKey\r\n    ? memoizedObfuscatedCoordinatesImpl(latlng, cacheKey)\r\n    : obfuscatedCoordinatesImpl(latlng);\r\n};\r\n\r\n/**\r\n * Query the user's current location from the browser API\r\n *\r\n * @return {Promise<LatLng>} user's current location\r\n */\r\nexport const userLocation = () =>\r\n  new Promise((resolve, reject) => {\r\n    const geolocationAvailable = 'geolocation' in navigator;\r\n\r\n    if (!geolocationAvailable) {\r\n      reject(new Error('Geolocation not available in browser'));\r\n      return;\r\n    }\r\n\r\n    // Some defaults for user's current geolocation call\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition\r\n    // Note: without high accuracy, the given location might differ quite much.\r\n    //       We decided that true would be better default for a template app.\r\n    const options = {\r\n      enableHighAccuracy: true,\r\n      timeout: 5000,\r\n      maximumAge: 0,\r\n    };\r\n\r\n    const onSuccess = position =>\r\n      resolve(new LatLng(position.coords.latitude, position.coords.longitude));\r\n\r\n    const onError = error => reject(error);\r\n\r\n    navigator.geolocation.getCurrentPosition(onSuccess, onError, options);\r\n  });\r\n\r\n/**\r\n * Calculate a circular polyline around the given point\r\n *\r\n * See: https://stackoverflow.com/questions/7316963/drawing-a-circle-google-static-maps\r\n *\r\n * @param {LatLng} latlng - center of the circle\r\n * @param {Number} radius - radius of the circle\r\n *\r\n * @return {Array<Array<Number>>} array of `[lat, lng]` coordinate\r\n * pairs forming the circle\r\n */\r\nexport const circlePolyline = (latlng, radius) => {\r\n  const { lat, lng } = latlng;\r\n  const detail = 8;\r\n  const R = 6371;\r\n  const pi = Math.PI;\r\n\r\n  const _lat = (lat * pi) / 180;\r\n  const _lng = (lng * pi) / 180;\r\n  const d = radius / 1000 / R;\r\n\r\n  let points = [];\r\n  for (let i = 0; i <= 360; i += detail) {\r\n    const brng = (i * pi) / 180;\r\n\r\n    let pLat = Math.asin(\r\n      Math.sin(_lat) * Math.cos(d) + Math.cos(_lat) * Math.sin(d) * Math.cos(brng)\r\n    );\r\n    const pLng =\r\n      ((_lng +\r\n        Math.atan2(\r\n          Math.sin(brng) * Math.sin(d) * Math.cos(_lat),\r\n          Math.cos(d) - Math.sin(_lat) * Math.sin(pLat)\r\n        )) *\r\n        180) /\r\n      pi;\r\n    pLat = (pLat * 180) / pi;\r\n\r\n    points.push([pLat, pLng]);\r\n  }\r\n\r\n  return points;\r\n};\r\n\r\n/**\r\n * Cut some precision from bounds coordinates to tackle subtle map movements\r\n * when map is moved manually\r\n *\r\n * @param {LatLngBounds} sdkBounds - bounds to be changed to fixed precision\r\n * @param {Number} fixedPrecision - integer to be used on tofixed() change.\r\n *\r\n * @return {LatLngBounds} - bounds cut to given fixed precision\r\n */\r\nexport const sdkBoundsToFixedCoordinates = (sdkBounds, fixedPrecision) => {\r\n  const fixed = n => Number.parseFloat(n.toFixed(fixedPrecision));\r\n  const ne = new LatLng(fixed(sdkBounds.ne.lat), fixed(sdkBounds.ne.lng));\r\n  const sw = new LatLng(fixed(sdkBounds.sw.lat), fixed(sdkBounds.sw.lng));\r\n\r\n  return new LatLngBounds(ne, sw);\r\n};\r\n\r\n/**\r\n * Check if given bounds object have the same coordinates\r\n *\r\n * @param {LatLngBounds} sdkBounds1 - bounds #1 to be compared\r\n * @param {LatLngBounds} sdkBounds2 - bounds #2 to be compared\r\n *\r\n * @return {boolean} - true if bounds are the same\r\n */\r\nexport const hasSameSDKBounds = (sdkBounds1, sdkBounds2) => {\r\n  if (!(sdkBounds1 instanceof LatLngBounds) || !(sdkBounds2 instanceof LatLngBounds)) {\r\n    return false;\r\n  }\r\n  return (\r\n    sdkBounds1.ne.lat === sdkBounds2.ne.lat &&\r\n    sdkBounds1.ne.lng === sdkBounds2.ne.lng &&\r\n    sdkBounds1.sw.lat === sdkBounds2.sw.lat &&\r\n    sdkBounds1.sw.lng === sdkBounds2.sw.lng\r\n  );\r\n};\r\n"]},"metadata":{},"sourceType":"module"}