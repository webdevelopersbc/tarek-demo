{"ast":null,"code":"var _jsxFileName = \"D:\\\\Amardeep\\\\tarek_project\\\\ftw-product\\\\src\\\\components\\\\LocationAutocompleteInput\\\\LocationAutocompleteInputImpl.js\";\nimport React, { Component } from 'react';\nimport { any, arrayOf, bool, func, number, shape, string, oneOfType, object } from 'prop-types';\nimport classNames from 'classnames';\nimport debounce from 'lodash/debounce';\nimport config from '../../config';\nimport { FormattedMessage } from '../../util/reactIntl';\nimport { propTypes } from '../../util/types';\nimport { IconSpinner } from '../../components';\nimport IconHourGlass from './IconHourGlass';\nimport IconCurrentLocation from './IconCurrentLocation';\nimport * as geocoderMapbox from './GeocoderMapbox';\nimport * as geocoderGoogleMaps from './GeocoderGoogleMaps';\nimport css from './LocationAutocompleteInput.module.css';\nconst isGoogleMapsInUse = config.maps.mapProvider === 'GOOGLE_MAPS';\nconst geocoderVariant = isGoogleMapsInUse ? geocoderGoogleMaps : geocoderMapbox;\nconst Geocoder = geocoderVariant.default;\nconst GeocoderAttribution = geocoderVariant.GeocoderAttribution;\nconst CURRENT_LOCATION_ID = geocoderVariant.CURRENT_LOCATION_ID; // A list of default predictions that can be shown when the user\n// focuses on the autocomplete input without typing a search. This can\n// be used to reduce typing and Geocoding API calls for common\n// searches.\n\nexport const defaultPredictions = (config.maps.search.suggestCurrentLocation ? [{\n  id: CURRENT_LOCATION_ID,\n  predictionPlace: {}\n}] : []).concat(config.maps.search.defaults);\nconst DEBOUNCE_WAIT_TIME = 300;\nconst DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES = 1000;\nconst KEY_CODE_ARROW_UP = 38;\nconst KEY_CODE_ARROW_DOWN = 40;\nconst KEY_CODE_ENTER = 13;\nconst KEY_CODE_TAB = 9;\nconst KEY_CODE_ESC = 27;\nconst DIRECTION_UP = 'up';\nconst DIRECTION_DOWN = 'down';\nconst TOUCH_TAP_RADIUS = 5; // Movement within 5px from touch start is considered a tap\n// Touch devices need to be able to distinguish touches for scrolling and touches to tap\n\nconst getTouchCoordinates = nativeEvent => {\n  const touch = nativeEvent && nativeEvent.changedTouches ? nativeEvent.changedTouches[0] : null;\n  return touch ? {\n    x: touch.screenX,\n    y: touch.screenY\n  } : null;\n}; // Renders the autocompletion prediction results in a list\n\n\nconst LocationPredictionsList = props => {\n  const {\n    rootClassName,\n    className,\n    attributionClassName,\n    predictions,\n    geocoder,\n    highlightedIndex,\n    onSelectStart,\n    onSelectMove,\n    onSelectEnd\n  } = props;\n\n  if (predictions.length === 0) {\n    return null;\n  }\n\n  const item = (prediction, index) => {\n    const isHighlighted = index === highlightedIndex;\n    const predictionId = geocoder.getPredictionId(prediction);\n    return /*#__PURE__*/React.createElement(\"li\", {\n      className: isHighlighted ? css.highlighted : null,\n      key: predictionId,\n      onTouchStart: e => {\n        e.preventDefault();\n        onSelectStart(getTouchCoordinates(e.nativeEvent));\n      },\n      onMouseDown: e => {\n        e.preventDefault();\n        onSelectStart();\n      },\n      onTouchMove: e => {\n        e.preventDefault();\n        onSelectMove(getTouchCoordinates(e.nativeEvent));\n      },\n      onTouchEnd: e => {\n        e.preventDefault();\n        onSelectEnd(prediction);\n      },\n      onMouseUp: e => {\n        e.preventDefault();\n        onSelectEnd(prediction);\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 73,\n        columnNumber: 7\n      }\n    }, predictionId === CURRENT_LOCATION_ID ? /*#__PURE__*/React.createElement(\"span\", {\n      className: css.currentLocation,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 11\n      }\n    }, /*#__PURE__*/React.createElement(IconCurrentLocation, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/React.createElement(FormattedMessage, {\n      id: \"LocationAutocompleteInput.currentLocation\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 100,\n        columnNumber: 13\n      }\n    })) : geocoder.getPredictionAddress(prediction));\n  };\n\n  const predictionRootMapProviderClass = isGoogleMapsInUse ? css.predictionsRootGoogle : css.predictionsRootMapbox;\n  const classes = classNames(rootClassName || css.predictionsRoot, predictionRootMapProviderClass, className);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: classes,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"ul\", {\n    className: css.predictions,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 7\n    }\n  }, predictions.map(item)), /*#__PURE__*/React.createElement(GeocoderAttribution, {\n    className: attributionClassName,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }\n  }));\n};\n\n_c = LocationPredictionsList;\nLocationPredictionsList.defaultProps = {\n  rootClassName: null,\n  className: null,\n  attributionClassName: null,\n  highlightedIndex: null\n};\nLocationPredictionsList.propTypes = {\n  rootClassName: string,\n  className: string,\n  attributionClassName: string,\n  predictions: arrayOf(object).isRequired,\n  geocoder: object.isRequired,\n  highlightedIndex: number,\n  onSelectStart: func.isRequired,\n  onSelectMove: func.isRequired,\n  onSelectEnd: func.isRequired\n}; // Get the current value with defaults from the given\n// LocationAutocompleteInput props.\n\nconst currentValue = props => {\n  const value = props.input.value || {};\n  const {\n    search = '',\n    predictions = [],\n    selectedPlace = null\n  } = value;\n  return {\n    search,\n    predictions,\n    selectedPlace\n  };\n};\n/*\r\n  Location auto completion input component\r\n\r\n  This component can work as the `component` prop to Final Form's\r\n  <Field /> component. It takes a custom input value shape, and\r\n  controls the onChange callback that is called with the input value.\r\n\r\n  The component works by listening to the underlying input component\r\n  and calling a Geocoder implementation for predictions. When the\r\n  predictions arrive, those are passed to Final Form in the onChange\r\n  callback.\r\n\r\n  See the LocationAutocompleteInput.example.js file for a usage\r\n  example within a form.\r\n*/\n\n\nclass LocationAutocompleteInputImpl extends Component {\n  constructor(props) {\n    super(props);\n    this._isMounted = false;\n    this.state = {\n      inputHasFocus: false,\n      selectionInProgress: false,\n      touchStartedFrom: null,\n      highlightedIndex: -1,\n      // -1 means no highlight\n      fetchingPlaceDetails: false,\n      fetchingPredictions: false\n    }; // Ref to the input element.\n\n    this.input = null;\n    this.shortQueryTimeout = null;\n    this.getGeocoder = this.getGeocoder.bind(this);\n    this.currentPredictions = this.currentPredictions.bind(this);\n    this.changeHighlight = this.changeHighlight.bind(this);\n    this.selectPrediction = this.selectPrediction.bind(this);\n    this.selectItemIfNoneSelected = this.selectItemIfNoneSelected.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n    this.onChange = this.onChange.bind(this);\n    this.handleOnBlur = this.handleOnBlur.bind(this);\n    this.handlePredictionsSelectStart = this.handlePredictionsSelectStart.bind(this);\n    this.handlePredictionsSelectMove = this.handlePredictionsSelectMove.bind(this);\n    this.handlePredictionsSelectEnd = this.handlePredictionsSelectEnd.bind(this);\n    this.finalizeSelection = this.finalizeSelection.bind(this); // Debounce the method to avoid calling the API too many times\n    // when the user is typing fast.\n\n    this.predict = debounce(this.predict.bind(this), DEBOUNCE_WAIT_TIME, {\n      leading: true\n    });\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n  }\n\n  componentWillUnmount() {\n    window.clearTimeout(this.shortQueryTimeout);\n    this._isMounted = false;\n  }\n\n  getGeocoder() {\n    // Create the Geocoder as late as possible only when it is needed.\n    if (!this._geocoder) {\n      this._geocoder = new Geocoder();\n    }\n\n    return this._geocoder;\n  }\n\n  currentPredictions() {\n    const {\n      search,\n      predictions: fetchedPredictions\n    } = currentValue(this.props);\n    const {\n      useDefaultPredictions\n    } = this.props;\n    const hasFetchedPredictions = fetchedPredictions && fetchedPredictions.length > 0;\n    const showDefaultPredictions = !search && !hasFetchedPredictions && useDefaultPredictions;\n    return showDefaultPredictions ? defaultPredictions : fetchedPredictions;\n  } // Interpret input key event\n\n\n  onKeyDown(e) {\n    if (e.keyCode === KEY_CODE_ARROW_UP) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_UP);\n    } else if (e.keyCode === KEY_CODE_ARROW_DOWN) {\n      // Prevent changing cursor position in input\n      e.preventDefault();\n      this.changeHighlight(DIRECTION_DOWN);\n    } else if (e.keyCode === KEY_CODE_ENTER) {\n      const {\n        selectedPlace\n      } = currentValue(this.props);\n\n      if (!selectedPlace) {\n        // Prevent form submit, try to select value instead.\n        e.preventDefault();\n        e.stopPropagation();\n        this.selectItemIfNoneSelected();\n        this.input.blur();\n      }\n    } else if (e.keyCode === KEY_CODE_TAB) {\n      this.selectItemIfNoneSelected();\n      this.input.blur();\n    } else if (e.keyCode === KEY_CODE_ESC && this.input) {\n      this.input.blur();\n    }\n  } // Handle input text change, fetch predictions if the value isn't empty\n\n\n  onChange(e) {\n    const onChange = this.props.input.onChange;\n    const predictions = this.currentPredictions();\n    const newValue = e.target.value; // Clear the current values since the input content is changed\n\n    onChange({\n      search: newValue,\n      predictions: newValue ? predictions : [],\n      selectedPlace: null\n    }); // Clear highlighted prediction since the input value changed and\n    // results will change as well\n\n    this.setState({\n      highlightedIndex: -1\n    });\n\n    if (!newValue) {\n      // No need to fetch predictions on empty input\n      return;\n    }\n\n    if (newValue.length >= 3) {\n      if (this.shortQueryTimeout) {\n        window.clearTimeout(this.shortQueryTimeout);\n      }\n\n      this.predict(newValue);\n    } else {\n      this.shortQueryTimeout = window.setTimeout(() => {\n        this.predict(newValue);\n      }, DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES);\n    }\n  } // Change the currently highlighted item by calculating the new\n  // index from the current state and the given direction number\n  // (DIRECTION_UP or DIRECTION_DOWN)\n\n\n  changeHighlight(direction) {\n    this.setState((prevState, props) => {\n      const predictions = this.currentPredictions();\n      const currentIndex = prevState.highlightedIndex;\n      let index = currentIndex;\n\n      if (direction === DIRECTION_UP) {\n        // Keep the first position if already highlighted\n        index = currentIndex === 0 ? 0 : currentIndex - 1;\n      } else if (direction === DIRECTION_DOWN) {\n        index = currentIndex + 1;\n      } // Check that the index is within the bounds\n\n\n      if (index < 0) {\n        index = -1;\n      } else if (index >= predictions.length) {\n        index = predictions.length - 1;\n      }\n\n      return {\n        highlightedIndex: index\n      };\n    });\n  } // Select the prediction in the given item. This will fetch/read the\n  // place details and set it as the selected place.\n\n\n  selectPrediction(prediction) {\n    this.props.input.onChange({ ...this.props.input,\n      selectedPlace: null\n    });\n    this.setState({\n      fetchingPlaceDetails: true\n    });\n    this.getGeocoder().getPlaceDetails(prediction).then(place => {\n      if (!this._isMounted) {\n        // Ignore if component already unmounted\n        return;\n      }\n\n      this.setState({\n        fetchingPlaceDetails: false\n      });\n      this.props.input.onChange({\n        search: place.address,\n        predictions: [],\n        selectedPlace: place\n      });\n    }).catch(e => {\n      this.setState({\n        fetchingPlaceDetails: false\n      }); // eslint-disable-next-line no-console\n\n      console.error(e);\n      this.props.input.onChange({ ...this.props.input.value,\n        selectedPlace: null\n      });\n    });\n  }\n\n  selectItemIfNoneSelected() {\n    if (this.state.fetchingPredictions) {\n      // No need to select anything since prediction fetch is still going on\n      return;\n    }\n\n    const {\n      search,\n      selectedPlace\n    } = currentValue(this.props);\n    const predictions = this.currentPredictions();\n\n    if (!selectedPlace) {\n      if (predictions && predictions.length > 0) {\n        const index = this.state.highlightedIndex !== -1 ? this.state.highlightedIndex : 0;\n        this.selectPrediction(predictions[index]);\n      } else {\n        this.predict(search);\n      }\n    }\n  }\n\n  predict(search) {\n    const onChange = this.props.input.onChange;\n    this.setState({\n      fetchingPredictions: true\n    });\n    return this.getGeocoder().getPlacePredictions(search).then(results => {\n      const {\n        search: currentSearch\n      } = currentValue(this.props);\n      this.setState({\n        fetchingPredictions: false\n      }); // If the earlier predictions arrive when the user has already\n      // changed the search term, ignore and wait until the latest\n      // predictions arrive. Without this logic, results for earlier\n      // requests would override whatever the user had typed since.\n      //\n      // This is essentially the same as switchLatest in RxJS or\n      // takeLatest in Redux Saga, without canceling the earlier\n      // requests.\n\n      if (results.search === currentSearch) {\n        onChange({\n          search: results.search,\n          predictions: results.predictions,\n          selectedPlace: null\n        });\n      }\n    }).catch(e => {\n      this.setState({\n        fetchingPredictions: false\n      }); // eslint-disable-next-line no-console\n\n      console.error(e);\n      const value = currentValue(this.props);\n      onChange({ ...value,\n        selectedPlace: null\n      });\n    });\n  }\n\n  finalizeSelection() {\n    this.setState({\n      inputHasFocus: false,\n      highlightedIndex: -1\n    });\n    this.props.input.onBlur(currentValue(this.props));\n  }\n\n  handleOnBlur() {\n    if (this.props.closeOnBlur && !this.state.selectionInProgress) {\n      this.finalizeSelection();\n    }\n  }\n\n  handlePredictionsSelectStart(touchCoordinates) {\n    this.setState({\n      selectionInProgress: true,\n      touchStartedFrom: touchCoordinates,\n      isSwipe: false\n    });\n  }\n\n  handlePredictionsSelectMove(touchCoordinates) {\n    this.setState(prevState => {\n      const touchStartedFrom = prevState.touchStartedFrom;\n      const isTouchAction = !!touchStartedFrom;\n      const isSwipe = isTouchAction ? Math.abs(touchStartedFrom.y - touchCoordinates.y) > TOUCH_TAP_RADIUS : false;\n      return {\n        selectionInProgress: false,\n        isSwipe\n      };\n    });\n  }\n\n  handlePredictionsSelectEnd(prediction) {\n    let selectAndFinalize = false;\n    this.setState(prevState => {\n      if (!prevState.isSwipe) {\n        selectAndFinalize = true;\n      }\n\n      return {\n        selectionInProgress: false,\n        touchStartedFrom: null,\n        isSwipe: false\n      };\n    }, () => {\n      if (selectAndFinalize) {\n        this.selectPrediction(prediction);\n        this.finalizeSelection();\n      }\n    });\n  }\n\n  render() {\n    const {\n      autoFocus,\n      rootClassName,\n      className,\n      iconClassName,\n      inputClassName,\n      predictionsClassName,\n      predictionsAttributionClassName,\n      validClassName,\n      placeholder,\n      input,\n      meta,\n      inputRef,\n      disabled\n    } = this.props;\n    const {\n      name,\n      onFocus\n    } = input;\n    const {\n      search\n    } = currentValue(this.props);\n    const {\n      touched,\n      valid\n    } = meta || {};\n    const isValid = valid && touched;\n    const predictions = this.currentPredictions();\n\n    const handleOnFocus = e => {\n      this.setState({\n        inputHasFocus: true\n      });\n      onFocus(e);\n    };\n\n    const rootClass = classNames(rootClassName || css.root, className);\n    const iconClass = classNames(iconClassName || css.icon);\n    const inputClass = classNames(inputClassName || css.input, {\n      [validClassName]: isValid\n    });\n    const predictionsClass = classNames(predictionsClassName); // Only render predictions when the input has focus. For\n    // development and easier workflow with the browser devtools, you\n    // might want to hardcode this to `true`. Otherwise the dropdown\n    // list will disappear.\n\n    const renderPredictions = this.state.inputHasFocus;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      className: rootClass,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 497,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      className: iconClass,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 498,\n        columnNumber: 9\n      }\n    }, this.state.fetchingPlaceDetails ? /*#__PURE__*/React.createElement(IconSpinner, {\n      className: css.iconSpinner,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 500,\n        columnNumber: 13\n      }\n    }) : /*#__PURE__*/React.createElement(IconHourGlass, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 502,\n        columnNumber: 13\n      }\n    })), /*#__PURE__*/React.createElement(\"input\", {\n      className: inputClass,\n      type: \"search\",\n      autoComplete: \"off\",\n      autoFocus: autoFocus,\n      placeholder: placeholder,\n      name: name,\n      value: search,\n      disabled: disabled || this.state.fetchingPlaceDetails,\n      onFocus: handleOnFocus,\n      onBlur: this.handleOnBlur,\n      onChange: this.onChange,\n      onKeyDown: this.onKeyDown,\n      ref: node => {\n        this.input = node;\n\n        if (inputRef) {\n          inputRef(node);\n        }\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 505,\n        columnNumber: 9\n      }\n    }), renderPredictions ? /*#__PURE__*/React.createElement(LocationPredictionsList, {\n      rootClassName: predictionsClass,\n      attributionClassName: predictionsAttributionClassName,\n      predictions: predictions,\n      geocoder: this.getGeocoder(),\n      highlightedIndex: this.state.highlightedIndex,\n      onSelectStart: this.handlePredictionsSelectStart,\n      onSelectMove: this.handlePredictionsSelectMove,\n      onSelectEnd: this.handlePredictionsSelectEnd,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 526,\n        columnNumber: 11\n      }\n    }) : null);\n  }\n\n}\n\nLocationAutocompleteInputImpl.defaultProps = {\n  autoFocus: false,\n  closeOnBlur: true,\n  rootClassName: null,\n  className: null,\n  iconClassName: null,\n  inputClassName: null,\n  predictionsClassName: null,\n  predictionsAttributionClassName: null,\n  validClassName: null,\n  placeholder: '',\n  useDefaultPredictions: true,\n  meta: null,\n  inputRef: null\n};\nLocationAutocompleteInputImpl.propTypes = {\n  autoFocus: bool,\n  rootClassName: string,\n  className: string,\n  closeOnBlur: bool,\n  iconClassName: string,\n  inputClassName: string,\n  predictionsClassName: string,\n  predictionsAttributionClassName: string,\n  validClassName: string,\n  placeholder: string,\n  useDefaultPredictions: bool,\n  input: shape({\n    name: string.isRequired,\n    value: oneOfType([shape({\n      search: string,\n      predictions: any,\n      selectedPlace: propTypes.place\n    }), string]),\n    onChange: func.isRequired,\n    onFocus: func.isRequired,\n    onBlur: func.isRequired\n  }).isRequired,\n  meta: shape({\n    valid: bool.isRequired,\n    touched: bool.isRequired\n  }),\n  inputRef: func\n};\nexport default LocationAutocompleteInputImpl;\n\nvar _c;\n\n$RefreshReg$(_c, \"LocationPredictionsList\");","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/components/LocationAutocompleteInput/LocationAutocompleteInputImpl.js"],"names":["React","Component","any","arrayOf","bool","func","number","shape","string","oneOfType","object","classNames","debounce","config","FormattedMessage","propTypes","IconSpinner","IconHourGlass","IconCurrentLocation","geocoderMapbox","geocoderGoogleMaps","css","isGoogleMapsInUse","maps","mapProvider","geocoderVariant","Geocoder","default","GeocoderAttribution","CURRENT_LOCATION_ID","defaultPredictions","search","suggestCurrentLocation","id","predictionPlace","concat","defaults","DEBOUNCE_WAIT_TIME","DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES","KEY_CODE_ARROW_UP","KEY_CODE_ARROW_DOWN","KEY_CODE_ENTER","KEY_CODE_TAB","KEY_CODE_ESC","DIRECTION_UP","DIRECTION_DOWN","TOUCH_TAP_RADIUS","getTouchCoordinates","nativeEvent","touch","changedTouches","x","screenX","y","screenY","LocationPredictionsList","props","rootClassName","className","attributionClassName","predictions","geocoder","highlightedIndex","onSelectStart","onSelectMove","onSelectEnd","length","item","prediction","index","isHighlighted","predictionId","getPredictionId","highlighted","e","preventDefault","currentLocation","getPredictionAddress","predictionRootMapProviderClass","predictionsRootGoogle","predictionsRootMapbox","classes","predictionsRoot","map","defaultProps","isRequired","currentValue","value","input","selectedPlace","LocationAutocompleteInputImpl","constructor","_isMounted","state","inputHasFocus","selectionInProgress","touchStartedFrom","fetchingPlaceDetails","fetchingPredictions","shortQueryTimeout","getGeocoder","bind","currentPredictions","changeHighlight","selectPrediction","selectItemIfNoneSelected","onKeyDown","onChange","handleOnBlur","handlePredictionsSelectStart","handlePredictionsSelectMove","handlePredictionsSelectEnd","finalizeSelection","predict","leading","componentDidMount","componentWillUnmount","window","clearTimeout","_geocoder","fetchedPredictions","useDefaultPredictions","hasFetchedPredictions","showDefaultPredictions","keyCode","stopPropagation","blur","newValue","target","setState","setTimeout","direction","prevState","currentIndex","getPlaceDetails","then","place","address","catch","console","error","getPlacePredictions","results","currentSearch","onBlur","closeOnBlur","touchCoordinates","isSwipe","isTouchAction","Math","abs","selectAndFinalize","render","autoFocus","iconClassName","inputClassName","predictionsClassName","predictionsAttributionClassName","validClassName","placeholder","meta","inputRef","disabled","name","onFocus","touched","valid","isValid","handleOnFocus","rootClass","root","iconClass","icon","inputClass","predictionsClass","renderPredictions","iconSpinner","node"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport { any, arrayOf, bool, func, number, shape, string, oneOfType, object } from 'prop-types';\r\nimport classNames from 'classnames';\r\nimport debounce from 'lodash/debounce';\r\n\r\nimport config from '../../config';\r\nimport { FormattedMessage } from '../../util/reactIntl';\r\nimport { propTypes } from '../../util/types';\r\n\r\nimport { IconSpinner } from '../../components';\r\n\r\nimport IconHourGlass from './IconHourGlass';\r\nimport IconCurrentLocation from './IconCurrentLocation';\r\nimport * as geocoderMapbox from './GeocoderMapbox';\r\nimport * as geocoderGoogleMaps from './GeocoderGoogleMaps';\r\n\r\nimport css from './LocationAutocompleteInput.module.css';\r\n\r\nconst isGoogleMapsInUse = config.maps.mapProvider === 'GOOGLE_MAPS';\r\nconst geocoderVariant = isGoogleMapsInUse ? geocoderGoogleMaps : geocoderMapbox;\r\nconst Geocoder = geocoderVariant.default;\r\nconst GeocoderAttribution = geocoderVariant.GeocoderAttribution;\r\nconst CURRENT_LOCATION_ID = geocoderVariant.CURRENT_LOCATION_ID;\r\n\r\n// A list of default predictions that can be shown when the user\r\n// focuses on the autocomplete input without typing a search. This can\r\n// be used to reduce typing and Geocoding API calls for common\r\n// searches.\r\nexport const defaultPredictions = (config.maps.search.suggestCurrentLocation\r\n  ? [{ id: CURRENT_LOCATION_ID, predictionPlace: {} }]\r\n  : []\r\n).concat(config.maps.search.defaults);\r\n\r\nconst DEBOUNCE_WAIT_TIME = 300;\r\nconst DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES = 1000;\r\nconst KEY_CODE_ARROW_UP = 38;\r\nconst KEY_CODE_ARROW_DOWN = 40;\r\nconst KEY_CODE_ENTER = 13;\r\nconst KEY_CODE_TAB = 9;\r\nconst KEY_CODE_ESC = 27;\r\nconst DIRECTION_UP = 'up';\r\nconst DIRECTION_DOWN = 'down';\r\nconst TOUCH_TAP_RADIUS = 5; // Movement within 5px from touch start is considered a tap\r\n\r\n// Touch devices need to be able to distinguish touches for scrolling and touches to tap\r\nconst getTouchCoordinates = nativeEvent => {\r\n  const touch = nativeEvent && nativeEvent.changedTouches ? nativeEvent.changedTouches[0] : null;\r\n  return touch ? { x: touch.screenX, y: touch.screenY } : null;\r\n};\r\n\r\n// Renders the autocompletion prediction results in a list\r\nconst LocationPredictionsList = props => {\r\n  const {\r\n    rootClassName,\r\n    className,\r\n    attributionClassName,\r\n    predictions,\r\n    geocoder,\r\n    highlightedIndex,\r\n    onSelectStart,\r\n    onSelectMove,\r\n    onSelectEnd,\r\n  } = props;\r\n  if (predictions.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const item = (prediction, index) => {\r\n    const isHighlighted = index === highlightedIndex;\r\n    const predictionId = geocoder.getPredictionId(prediction);\r\n\r\n    return (\r\n      <li\r\n        className={isHighlighted ? css.highlighted : null}\r\n        key={predictionId}\r\n        onTouchStart={e => {\r\n          e.preventDefault();\r\n          onSelectStart(getTouchCoordinates(e.nativeEvent));\r\n        }}\r\n        onMouseDown={e => {\r\n          e.preventDefault();\r\n          onSelectStart();\r\n        }}\r\n        onTouchMove={e => {\r\n          e.preventDefault();\r\n          onSelectMove(getTouchCoordinates(e.nativeEvent));\r\n        }}\r\n        onTouchEnd={e => {\r\n          e.preventDefault();\r\n          onSelectEnd(prediction);\r\n        }}\r\n        onMouseUp={e => {\r\n          e.preventDefault();\r\n          onSelectEnd(prediction);\r\n        }}\r\n      >\r\n        {predictionId === CURRENT_LOCATION_ID ? (\r\n          <span className={css.currentLocation}>\r\n            <IconCurrentLocation />\r\n            <FormattedMessage id=\"LocationAutocompleteInput.currentLocation\" />\r\n          </span>\r\n        ) : (\r\n          geocoder.getPredictionAddress(prediction)\r\n        )}\r\n      </li>\r\n    );\r\n  };\r\n\r\n  const predictionRootMapProviderClass = isGoogleMapsInUse\r\n    ? css.predictionsRootGoogle\r\n    : css.predictionsRootMapbox;\r\n  const classes = classNames(\r\n    rootClassName || css.predictionsRoot,\r\n    predictionRootMapProviderClass,\r\n    className\r\n  );\r\n\r\n  return (\r\n    <div className={classes}>\r\n      <ul className={css.predictions}>{predictions.map(item)}</ul>\r\n      <GeocoderAttribution className={attributionClassName} />\r\n    </div>\r\n  );\r\n};\r\n\r\nLocationPredictionsList.defaultProps = {\r\n  rootClassName: null,\r\n  className: null,\r\n  attributionClassName: null,\r\n  highlightedIndex: null,\r\n};\r\n\r\nLocationPredictionsList.propTypes = {\r\n  rootClassName: string,\r\n  className: string,\r\n  attributionClassName: string,\r\n  predictions: arrayOf(object).isRequired,\r\n  geocoder: object.isRequired,\r\n  highlightedIndex: number,\r\n  onSelectStart: func.isRequired,\r\n  onSelectMove: func.isRequired,\r\n  onSelectEnd: func.isRequired,\r\n};\r\n\r\n// Get the current value with defaults from the given\r\n// LocationAutocompleteInput props.\r\nconst currentValue = props => {\r\n  const value = props.input.value || {};\r\n  const { search = '', predictions = [], selectedPlace = null } = value;\r\n  return { search, predictions, selectedPlace };\r\n};\r\n\r\n/*\r\n  Location auto completion input component\r\n\r\n  This component can work as the `component` prop to Final Form's\r\n  <Field /> component. It takes a custom input value shape, and\r\n  controls the onChange callback that is called with the input value.\r\n\r\n  The component works by listening to the underlying input component\r\n  and calling a Geocoder implementation for predictions. When the\r\n  predictions arrive, those are passed to Final Form in the onChange\r\n  callback.\r\n\r\n  See the LocationAutocompleteInput.example.js file for a usage\r\n  example within a form.\r\n*/\r\nclass LocationAutocompleteInputImpl extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this._isMounted = false;\r\n\r\n    this.state = {\r\n      inputHasFocus: false,\r\n      selectionInProgress: false,\r\n      touchStartedFrom: null,\r\n      highlightedIndex: -1, // -1 means no highlight\r\n      fetchingPlaceDetails: false,\r\n      fetchingPredictions: false,\r\n    };\r\n\r\n    // Ref to the input element.\r\n    this.input = null;\r\n    this.shortQueryTimeout = null;\r\n\r\n    this.getGeocoder = this.getGeocoder.bind(this);\r\n    this.currentPredictions = this.currentPredictions.bind(this);\r\n    this.changeHighlight = this.changeHighlight.bind(this);\r\n    this.selectPrediction = this.selectPrediction.bind(this);\r\n    this.selectItemIfNoneSelected = this.selectItemIfNoneSelected.bind(this);\r\n    this.onKeyDown = this.onKeyDown.bind(this);\r\n    this.onChange = this.onChange.bind(this);\r\n    this.handleOnBlur = this.handleOnBlur.bind(this);\r\n    this.handlePredictionsSelectStart = this.handlePredictionsSelectStart.bind(this);\r\n    this.handlePredictionsSelectMove = this.handlePredictionsSelectMove.bind(this);\r\n    this.handlePredictionsSelectEnd = this.handlePredictionsSelectEnd.bind(this);\r\n    this.finalizeSelection = this.finalizeSelection.bind(this);\r\n\r\n    // Debounce the method to avoid calling the API too many times\r\n    // when the user is typing fast.\r\n    this.predict = debounce(this.predict.bind(this), DEBOUNCE_WAIT_TIME, { leading: true });\r\n  }\r\n\r\n  componentDidMount() {\r\n    this._isMounted = true;\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.clearTimeout(this.shortQueryTimeout);\r\n    this._isMounted = false;\r\n  }\r\n\r\n  getGeocoder() {\r\n    // Create the Geocoder as late as possible only when it is needed.\r\n    if (!this._geocoder) {\r\n      this._geocoder = new Geocoder();\r\n    }\r\n    return this._geocoder;\r\n  }\r\n\r\n  currentPredictions() {\r\n    const { search, predictions: fetchedPredictions } = currentValue(this.props);\r\n    const { useDefaultPredictions } = this.props;\r\n    const hasFetchedPredictions = fetchedPredictions && fetchedPredictions.length > 0;\r\n    const showDefaultPredictions = !search && !hasFetchedPredictions && useDefaultPredictions;\r\n\r\n    return showDefaultPredictions ? defaultPredictions : fetchedPredictions;\r\n  }\r\n\r\n  // Interpret input key event\r\n  onKeyDown(e) {\r\n    if (e.keyCode === KEY_CODE_ARROW_UP) {\r\n      // Prevent changing cursor position in input\r\n      e.preventDefault();\r\n      this.changeHighlight(DIRECTION_UP);\r\n    } else if (e.keyCode === KEY_CODE_ARROW_DOWN) {\r\n      // Prevent changing cursor position in input\r\n      e.preventDefault();\r\n      this.changeHighlight(DIRECTION_DOWN);\r\n    } else if (e.keyCode === KEY_CODE_ENTER) {\r\n      const { selectedPlace } = currentValue(this.props);\r\n\r\n      if (!selectedPlace) {\r\n        // Prevent form submit, try to select value instead.\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        this.selectItemIfNoneSelected();\r\n        this.input.blur();\r\n      }\r\n    } else if (e.keyCode === KEY_CODE_TAB) {\r\n      this.selectItemIfNoneSelected();\r\n      this.input.blur();\r\n    } else if (e.keyCode === KEY_CODE_ESC && this.input) {\r\n      this.input.blur();\r\n    }\r\n  }\r\n\r\n  // Handle input text change, fetch predictions if the value isn't empty\r\n  onChange(e) {\r\n    const onChange = this.props.input.onChange;\r\n    const predictions = this.currentPredictions();\r\n    const newValue = e.target.value;\r\n\r\n    // Clear the current values since the input content is changed\r\n    onChange({\r\n      search: newValue,\r\n      predictions: newValue ? predictions : [],\r\n      selectedPlace: null,\r\n    });\r\n\r\n    // Clear highlighted prediction since the input value changed and\r\n    // results will change as well\r\n    this.setState({ highlightedIndex: -1 });\r\n\r\n    if (!newValue) {\r\n      // No need to fetch predictions on empty input\r\n      return;\r\n    }\r\n\r\n    if (newValue.length >= 3) {\r\n      if (this.shortQueryTimeout) {\r\n        window.clearTimeout(this.shortQueryTimeout);\r\n      }\r\n      this.predict(newValue);\r\n    } else {\r\n      this.shortQueryTimeout = window.setTimeout(() => {\r\n        this.predict(newValue);\r\n      }, DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES);\r\n    }\r\n  }\r\n\r\n  // Change the currently highlighted item by calculating the new\r\n  // index from the current state and the given direction number\r\n  // (DIRECTION_UP or DIRECTION_DOWN)\r\n  changeHighlight(direction) {\r\n    this.setState((prevState, props) => {\r\n      const predictions = this.currentPredictions();\r\n      const currentIndex = prevState.highlightedIndex;\r\n      let index = currentIndex;\r\n\r\n      if (direction === DIRECTION_UP) {\r\n        // Keep the first position if already highlighted\r\n        index = currentIndex === 0 ? 0 : currentIndex - 1;\r\n      } else if (direction === DIRECTION_DOWN) {\r\n        index = currentIndex + 1;\r\n      }\r\n\r\n      // Check that the index is within the bounds\r\n      if (index < 0) {\r\n        index = -1;\r\n      } else if (index >= predictions.length) {\r\n        index = predictions.length - 1;\r\n      }\r\n\r\n      return { highlightedIndex: index };\r\n    });\r\n  }\r\n\r\n  // Select the prediction in the given item. This will fetch/read the\r\n  // place details and set it as the selected place.\r\n  selectPrediction(prediction) {\r\n    this.props.input.onChange({\r\n      ...this.props.input,\r\n      selectedPlace: null,\r\n    });\r\n\r\n    this.setState({ fetchingPlaceDetails: true });\r\n\r\n    this.getGeocoder()\r\n      .getPlaceDetails(prediction)\r\n      .then(place => {\r\n        if (!this._isMounted) {\r\n          // Ignore if component already unmounted\r\n          return;\r\n        }\r\n        this.setState({ fetchingPlaceDetails: false });\r\n        this.props.input.onChange({\r\n          search: place.address,\r\n          predictions: [],\r\n          selectedPlace: place,\r\n        });\r\n      })\r\n      .catch(e => {\r\n        this.setState({ fetchingPlaceDetails: false });\r\n        // eslint-disable-next-line no-console\r\n        console.error(e);\r\n        this.props.input.onChange({\r\n          ...this.props.input.value,\r\n          selectedPlace: null,\r\n        });\r\n      });\r\n  }\r\n  selectItemIfNoneSelected() {\r\n    if (this.state.fetchingPredictions) {\r\n      // No need to select anything since prediction fetch is still going on\r\n      return;\r\n    }\r\n\r\n    const { search, selectedPlace } = currentValue(this.props);\r\n    const predictions = this.currentPredictions();\r\n    if (!selectedPlace) {\r\n      if (predictions && predictions.length > 0) {\r\n        const index = this.state.highlightedIndex !== -1 ? this.state.highlightedIndex : 0;\r\n        this.selectPrediction(predictions[index]);\r\n      } else {\r\n        this.predict(search);\r\n      }\r\n    }\r\n  }\r\n  predict(search) {\r\n    const onChange = this.props.input.onChange;\r\n    this.setState({ fetchingPredictions: true });\r\n\r\n    return this.getGeocoder()\r\n      .getPlacePredictions(search)\r\n      .then(results => {\r\n        const { search: currentSearch } = currentValue(this.props);\r\n        this.setState({ fetchingPredictions: false });\r\n\r\n        // If the earlier predictions arrive when the user has already\r\n        // changed the search term, ignore and wait until the latest\r\n        // predictions arrive. Without this logic, results for earlier\r\n        // requests would override whatever the user had typed since.\r\n        //\r\n        // This is essentially the same as switchLatest in RxJS or\r\n        // takeLatest in Redux Saga, without canceling the earlier\r\n        // requests.\r\n        if (results.search === currentSearch) {\r\n          onChange({\r\n            search: results.search,\r\n            predictions: results.predictions,\r\n            selectedPlace: null,\r\n          });\r\n        }\r\n      })\r\n      .catch(e => {\r\n        this.setState({ fetchingPredictions: false });\r\n        // eslint-disable-next-line no-console\r\n        console.error(e);\r\n        const value = currentValue(this.props);\r\n        onChange({\r\n          ...value,\r\n          selectedPlace: null,\r\n        });\r\n      });\r\n  }\r\n\r\n  finalizeSelection() {\r\n    this.setState({ inputHasFocus: false, highlightedIndex: -1 });\r\n    this.props.input.onBlur(currentValue(this.props));\r\n  }\r\n\r\n  handleOnBlur() {\r\n    if (this.props.closeOnBlur && !this.state.selectionInProgress) {\r\n      this.finalizeSelection();\r\n    }\r\n  }\r\n\r\n  handlePredictionsSelectStart(touchCoordinates) {\r\n    this.setState({\r\n      selectionInProgress: true,\r\n      touchStartedFrom: touchCoordinates,\r\n      isSwipe: false,\r\n    });\r\n  }\r\n\r\n  handlePredictionsSelectMove(touchCoordinates) {\r\n    this.setState(prevState => {\r\n      const touchStartedFrom = prevState.touchStartedFrom;\r\n      const isTouchAction = !!touchStartedFrom;\r\n      const isSwipe = isTouchAction\r\n        ? Math.abs(touchStartedFrom.y - touchCoordinates.y) > TOUCH_TAP_RADIUS\r\n        : false;\r\n\r\n      return { selectionInProgress: false, isSwipe };\r\n    });\r\n  }\r\n\r\n  handlePredictionsSelectEnd(prediction) {\r\n    let selectAndFinalize = false;\r\n    this.setState(\r\n      prevState => {\r\n        if (!prevState.isSwipe) {\r\n          selectAndFinalize = true;\r\n        }\r\n        return { selectionInProgress: false, touchStartedFrom: null, isSwipe: false };\r\n      },\r\n      () => {\r\n        if (selectAndFinalize) {\r\n          this.selectPrediction(prediction);\r\n          this.finalizeSelection();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      autoFocus,\r\n      rootClassName,\r\n      className,\r\n      iconClassName,\r\n      inputClassName,\r\n      predictionsClassName,\r\n      predictionsAttributionClassName,\r\n      validClassName,\r\n      placeholder,\r\n      input,\r\n      meta,\r\n      inputRef,\r\n      disabled,\r\n    } = this.props;\r\n    const { name, onFocus } = input;\r\n    const { search } = currentValue(this.props);\r\n    const { touched, valid } = meta || {};\r\n    const isValid = valid && touched;\r\n    const predictions = this.currentPredictions();\r\n\r\n    const handleOnFocus = e => {\r\n      this.setState({ inputHasFocus: true });\r\n      onFocus(e);\r\n    };\r\n\r\n    const rootClass = classNames(rootClassName || css.root, className);\r\n    const iconClass = classNames(iconClassName || css.icon);\r\n    const inputClass = classNames(inputClassName || css.input, { [validClassName]: isValid });\r\n    const predictionsClass = classNames(predictionsClassName);\r\n\r\n    // Only render predictions when the input has focus. For\r\n    // development and easier workflow with the browser devtools, you\r\n    // might want to hardcode this to `true`. Otherwise the dropdown\r\n    // list will disappear.\r\n    const renderPredictions = this.state.inputHasFocus;\r\n\r\n    return (\r\n      <div className={rootClass}>\r\n        <div className={iconClass}>\r\n          {this.state.fetchingPlaceDetails ? (\r\n            <IconSpinner className={css.iconSpinner} />\r\n          ) : (\r\n            <IconHourGlass />\r\n          )}\r\n        </div>\r\n        <input\r\n          className={inputClass}\r\n          type=\"search\"\r\n          autoComplete=\"off\"\r\n          autoFocus={autoFocus}\r\n          placeholder={placeholder}\r\n          name={name}\r\n          value={search}\r\n          disabled={disabled || this.state.fetchingPlaceDetails}\r\n          onFocus={handleOnFocus}\r\n          onBlur={this.handleOnBlur}\r\n          onChange={this.onChange}\r\n          onKeyDown={this.onKeyDown}\r\n          ref={node => {\r\n            this.input = node;\r\n            if (inputRef) {\r\n              inputRef(node);\r\n            }\r\n          }}\r\n        />\r\n        {renderPredictions ? (\r\n          <LocationPredictionsList\r\n            rootClassName={predictionsClass}\r\n            attributionClassName={predictionsAttributionClassName}\r\n            predictions={predictions}\r\n            geocoder={this.getGeocoder()}\r\n            highlightedIndex={this.state.highlightedIndex}\r\n            onSelectStart={this.handlePredictionsSelectStart}\r\n            onSelectMove={this.handlePredictionsSelectMove}\r\n            onSelectEnd={this.handlePredictionsSelectEnd}\r\n          />\r\n        ) : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nLocationAutocompleteInputImpl.defaultProps = {\r\n  autoFocus: false,\r\n  closeOnBlur: true,\r\n  rootClassName: null,\r\n  className: null,\r\n  iconClassName: null,\r\n  inputClassName: null,\r\n  predictionsClassName: null,\r\n  predictionsAttributionClassName: null,\r\n  validClassName: null,\r\n  placeholder: '',\r\n  useDefaultPredictions: true,\r\n  meta: null,\r\n  inputRef: null,\r\n};\r\n\r\nLocationAutocompleteInputImpl.propTypes = {\r\n  autoFocus: bool,\r\n  rootClassName: string,\r\n  className: string,\r\n  closeOnBlur: bool,\r\n  iconClassName: string,\r\n  inputClassName: string,\r\n  predictionsClassName: string,\r\n  predictionsAttributionClassName: string,\r\n  validClassName: string,\r\n  placeholder: string,\r\n  useDefaultPredictions: bool,\r\n  input: shape({\r\n    name: string.isRequired,\r\n    value: oneOfType([\r\n      shape({\r\n        search: string,\r\n        predictions: any,\r\n        selectedPlace: propTypes.place,\r\n      }),\r\n      string,\r\n    ]),\r\n    onChange: func.isRequired,\r\n    onFocus: func.isRequired,\r\n    onBlur: func.isRequired,\r\n  }).isRequired,\r\n  meta: shape({\r\n    valid: bool.isRequired,\r\n    touched: bool.isRequired,\r\n  }),\r\n  inputRef: func,\r\n};\r\n\r\nexport default LocationAutocompleteInputImpl;\r\n"]},"metadata":{},"sourceType":"module"}