{"ast":null,"code":"import { ensureTransaction } from './data';\n/**\r\n * Transitions\r\n *\r\n * These strings must sync with values defined in Flex API,\r\n * since transaction objects given by API contain info about last transitions.\r\n * All the actions in API side happen in transitions,\r\n * so we need to understand what those strings mean.\r\n */\n// When a customer makes an order for a listing, a transaction is\n// created with the initial request-payment transition.\n// At this transition a PaymentIntent is created by Marketplace API.\n// After this transition, the actual payment must be made on client-side directly to Stripe.\n\nexport const TRANSITION_REQUEST_PAYMENT = 'transition/request-payment'; // A customer can also initiate a transaction with an enquiry, and\n// then transition that with a request.\n\nexport const TRANSITION_ENQUIRE = 'transition/enquire';\nexport const TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY = 'transition/request-payment-after-enquiry'; // Stripe SDK might need to ask 3D security from customer, in a separate front-end step.\n// Therefore we need to make another transition to Marketplace API,\n// to tell that the payment is confirmed.\n\nexport const TRANSITION_CONFIRM_PAYMENT = 'transition/confirm-payment'; // If the payment is not confirmed in the time limit set in transaction process (by default 15min)\n// the transaction will expire automatically.\n\nexport const TRANSITION_EXPIRE_PAYMENT = 'transition/expire-payment'; // Provider can mark the product shipped/delivered\n\nexport const TRANSITION_MARK_DELIVERED = 'transition/mark-delivered'; // Customer can mark the product received (e.g. picked up from provider)\n\nexport const TRANSITION_MARK_RECEIVED_FROM_PURCHASED = 'transition/mark-received-from-purchased'; // Automatic cancellation happens if none marks the delivery happened\n\nexport const TRANSITION_AUTO_CANCEL = 'transition/auto-cancel'; // Operator can cancel the purchase before product has been marked as delivered / received\n\nexport const TRANSITION_CANCEL = 'transition/cancel'; // If provider has marked the product delivered (e.g. shipped),\n// customer can then mark the product received\n\nexport const TRANSITION_MARK_RECEIVED = 'transition/mark-received'; // If customer doesn't mark the product received manually, it can happen automatically\n\nexport const TRANSITION_AUTO_MARK_RECEIVED = 'transition/auto-mark-received'; // When provider has marked the product delivered, customer can dispute the transaction\n\nexport const TRANSITION_DISPUTE = 'transition/dispute'; // If nothing is done to disputed transaction it ends up to Canceled state\n\nexport const TRANSITION_AUTO_CANCEL_FROM_DISPUTED = 'transition/auto-cancel-from-disputed'; // Operator can cancel disputed transaction manually\n\nexport const TRANSITION_CANCEL_FROM_DISPUTED = 'transition/cancel-from-disputed'; // Operator can mark the disputed transaction as received\n\nexport const TRANSITION_MARK_RECEIVED_FROM_DISPUTED = 'transition/mark-received-from-disputed'; // System moves transaction automatically from received state to complete state\n// This makes it possible to to add notifications to that single transition.\n\nexport const TRANSITION_AUTO_COMPLETE = 'transition/auto-complete'; // Reviews are given through transaction transitions. Review 1 can be\n// by provider or customer, and review 2 will be the other party of\n// the transaction.\n\nexport const TRANSITION_REVIEW_1_BY_PROVIDER = 'transition/review-1-by-provider';\nexport const TRANSITION_REVIEW_2_BY_PROVIDER = 'transition/review-2-by-provider';\nexport const TRANSITION_REVIEW_1_BY_CUSTOMER = 'transition/review-1-by-customer';\nexport const TRANSITION_REVIEW_2_BY_CUSTOMER = 'transition/review-2-by-customer';\nexport const TRANSITION_EXPIRE_CUSTOMER_REVIEW_PERIOD = 'transition/expire-customer-review-period';\nexport const TRANSITION_EXPIRE_PROVIDER_REVIEW_PERIOD = 'transition/expire-provider-review-period';\nexport const TRANSITION_EXPIRE_REVIEW_PERIOD = 'transition/expire-review-period';\n/**\r\n * Actors\r\n *\r\n * There are 4 different actors that might initiate transitions:\r\n */\n// Roles of actors that perform transaction transitions\n\nexport const TX_TRANSITION_ACTOR_CUSTOMER = 'customer';\nexport const TX_TRANSITION_ACTOR_PROVIDER = 'provider';\nexport const TX_TRANSITION_ACTOR_SYSTEM = 'system';\nexport const TX_TRANSITION_ACTOR_OPERATOR = 'operator';\nexport const TX_TRANSITION_ACTORS = [TX_TRANSITION_ACTOR_CUSTOMER, TX_TRANSITION_ACTOR_PROVIDER, TX_TRANSITION_ACTOR_SYSTEM, TX_TRANSITION_ACTOR_OPERATOR];\n/**\r\n * States\r\n *\r\n * These constants are only for making it clear how transitions work together.\r\n * You should not use these constants outside of this file.\r\n *\r\n * Note: these states are not in sync with states used transaction process definitions\r\n *       in Marketplace API. Only last transitions are passed along transaction object.\r\n */\n\nconst STATE_INITIAL = 'initial';\nconst STATE_ENQUIRY = 'enquiry';\nconst STATE_PENDING_PAYMENT = 'pending-payment';\nconst STATE_PAYMENT_EXPIRED = 'payment-expired';\nconst STATE_PURCHASED = 'purchased';\nconst STATE_DELIVERED = 'delivered';\nconst STATE_RECEIVED = 'received';\nconst STATE_DISPUTED = 'disputed';\nconst STATE_CANCELED = 'canceled';\nconst STATE_COMPLETED = 'completed';\nconst STATE_REVIEWED = 'reviewed';\nconst STATE_REVIEWED_BY_CUSTOMER = 'reviewed-by-customer';\nconst STATE_REVIEWED_BY_PROVIDER = 'reviewed-by-provider';\n/**\r\n * Description of transaction process\r\n *\r\n * You should keep this in sync with transaction process defined in Marketplace API\r\n *\r\n * Note: we don't use yet any state machine library,\r\n *       but this description format is following Xstate (FSM library)\r\n *       https://xstate.js.org/docs/\r\n */\n\nconst stateDescription = {\n  // id is defined only to support Xstate format.\n  // However if you have multiple transaction processes defined,\n  // it is best to keep them in sync with transaction process aliases.\n  id: 'flex-product-default-process/release-1',\n  // This 'initial' state is a starting point for new transaction\n  initial: STATE_INITIAL,\n  // States\n  states: {\n    [STATE_INITIAL]: {\n      on: {\n        [TRANSITION_ENQUIRE]: STATE_ENQUIRY,\n        [TRANSITION_REQUEST_PAYMENT]: STATE_PENDING_PAYMENT\n      }\n    },\n    [STATE_ENQUIRY]: {\n      on: {\n        [TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY]: STATE_PENDING_PAYMENT\n      }\n    },\n    [STATE_PENDING_PAYMENT]: {\n      on: {\n        [TRANSITION_EXPIRE_PAYMENT]: STATE_PAYMENT_EXPIRED,\n        [TRANSITION_CONFIRM_PAYMENT]: STATE_PURCHASED\n      }\n    },\n    [STATE_PAYMENT_EXPIRED]: {},\n    [STATE_PURCHASED]: {\n      on: {\n        [TRANSITION_MARK_DELIVERED]: STATE_DELIVERED,\n        [TRANSITION_MARK_RECEIVED_FROM_PURCHASED]: STATE_RECEIVED,\n        [TRANSITION_AUTO_CANCEL]: STATE_CANCELED,\n        [TRANSITION_CANCEL]: STATE_CANCELED\n      }\n    },\n    [STATE_CANCELED]: {},\n    [STATE_DELIVERED]: {\n      on: {\n        [TRANSITION_MARK_RECEIVED]: STATE_RECEIVED,\n        [TRANSITION_AUTO_MARK_RECEIVED]: STATE_RECEIVED,\n        [TRANSITION_DISPUTE]: STATE_DISPUTED\n      }\n    },\n    [STATE_DISPUTED]: {\n      on: {\n        [TRANSITION_AUTO_CANCEL_FROM_DISPUTED]: STATE_CANCELED,\n        [TRANSITION_CANCEL_FROM_DISPUTED]: STATE_CANCELED,\n        [TRANSITION_MARK_RECEIVED_FROM_DISPUTED]: STATE_RECEIVED\n      }\n    },\n    [STATE_RECEIVED]: {\n      on: {\n        [TRANSITION_AUTO_COMPLETE]: STATE_COMPLETED\n      }\n    },\n    [STATE_COMPLETED]: {\n      on: {\n        [TRANSITION_EXPIRE_REVIEW_PERIOD]: STATE_REVIEWED,\n        [TRANSITION_REVIEW_1_BY_CUSTOMER]: STATE_REVIEWED_BY_CUSTOMER,\n        [TRANSITION_REVIEW_1_BY_PROVIDER]: STATE_REVIEWED_BY_PROVIDER\n      }\n    },\n    [STATE_REVIEWED_BY_CUSTOMER]: {\n      on: {\n        [TRANSITION_REVIEW_2_BY_PROVIDER]: STATE_REVIEWED,\n        [TRANSITION_EXPIRE_PROVIDER_REVIEW_PERIOD]: STATE_REVIEWED\n      }\n    },\n    [STATE_REVIEWED_BY_PROVIDER]: {\n      on: {\n        [TRANSITION_REVIEW_2_BY_CUSTOMER]: STATE_REVIEWED,\n        [TRANSITION_EXPIRE_CUSTOMER_REVIEW_PERIOD]: STATE_REVIEWED\n      }\n    },\n    [STATE_REVIEWED]: {\n      type: 'final'\n    }\n  }\n}; // Note: currently we assume that state description doesn't contain nested states.\n\nconst statesFromStateDescription = description => description.states || {}; // Get all the transitions from states object in an array\n\n\nconst getTransitions = states => {\n  const stateNames = Object.keys(states);\n\n  const transitionsReducer = (transitionArray, name) => {\n    const stateTransitions = states[name] && states[name].on;\n    const transitionKeys = stateTransitions ? Object.keys(stateTransitions) : [];\n    return [...transitionArray, ...transitionKeys.map(key => ({\n      key,\n      value: stateTransitions[key]\n    }))];\n  };\n\n  return stateNames.reduce(transitionsReducer, []);\n}; // This is a list of all the transitions that this app should be able to handle.\n\n\nexport const TRANSITIONS = getTransitions(statesFromStateDescription(stateDescription)).map(_c = t => t.key); // This function returns a function that has given stateDesc in scope chain.\n\n_c2 = TRANSITIONS;\n\nconst getTransitionsToStateFn = stateDesc => state => getTransitions(statesFromStateDescription(stateDesc)).filter(t => t.value === state).map(t => t.key); // Get all the transitions that lead to specified state.\n\n\nconst getTransitionsToState = getTransitionsToStateFn(stateDescription); // This is needed to fetch transactions that need response from provider.\n// I.e. transactions which provider needs to accept or decline\n\nexport const transitionsToRequested = getTransitionsToState(STATE_PURCHASED);\n/**\r\n * Helper functions to figure out if transaction is in a specific state.\r\n * State is based on lastTransition given by transaction object and state description.\r\n */\n\nconst txLastTransition = tx => ensureTransaction(tx).attributes.lastTransition;\n\nexport const txIsEnquired = tx => getTransitionsToState(STATE_ENQUIRY).includes(txLastTransition(tx));\nexport const txIsPaymentPending = tx => getTransitionsToState(STATE_PENDING_PAYMENT).includes(txLastTransition(tx));\nexport const txIsPaymentExpired = tx => getTransitionsToState(STATE_PAYMENT_EXPIRED).includes(txLastTransition(tx));\nexport const txIsPurchased = tx => getTransitionsToState(STATE_PURCHASED).includes(txLastTransition(tx));\nexport const txIsCanceled = tx => getTransitionsToState(STATE_CANCELED).includes(txLastTransition(tx));\nexport const txIsDelivered = tx => getTransitionsToState(STATE_DELIVERED).includes(txLastTransition(tx));\nexport const txIsDisputed = tx => getTransitionsToState(STATE_DISPUTED).includes(txLastTransition(tx));\nexport const txIsReceived = tx => getTransitionsToState(STATE_RECEIVED).includes(txLastTransition(tx));\nexport const txIsCompleted = tx => getTransitionsToState(STATE_COMPLETED).includes(txLastTransition(tx));\nexport const txIsReviewedByCustomer = tx => getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(txLastTransition(tx));\nexport const txIsReviewedByProvider = tx => getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(txLastTransition(tx));\nconst firstReviewTransitions = [...getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER), ...getTransitionsToState(STATE_REVIEWED_BY_PROVIDER)];\nexport const txIsInFirstReview = tx => firstReviewTransitions.includes(txLastTransition(tx));\nexport const txIsInFirstReviewBy = (tx, isCustomer) => isCustomer ? getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(txLastTransition(tx)) : getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(txLastTransition(tx));\nexport const txIsReviewed = tx => getTransitionsToState(STATE_REVIEWED).includes(txLastTransition(tx));\n/**\r\n * Helper functions to figure out if transaction has passed a given state.\r\n * This is based on transitions history given by transaction object.\r\n */\n\nconst txTransitions = tx => ensureTransaction(tx).attributes.transitions || [];\n\nconst hasPassedTransition = (transitionName, tx) => !!txTransitions(tx).find(t => t.transition === transitionName);\n\nconst hasPassedStateFn = state => tx => getTransitionsToState(state).filter(t => hasPassedTransition(t, tx)).length > 0; // Helper function to check if the transaction has passed a certain state\n\n\nexport const txHasPassedPaymentPending = hasPassedStateFn(STATE_PENDING_PAYMENT);\nexport const txHasBeenReceived = hasPassedStateFn(STATE_RECEIVED);\n/**\r\n * Other transaction related utility functions\r\n */\n\nexport const transitionIsReviewed = transition => getTransitionsToState(STATE_REVIEWED).includes(transition);\nexport const transitionIsFirstReviewedBy = (transition, isCustomer) => isCustomer ? getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(transition) : getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(transition);\nexport const getReview1Transition = isCustomer => isCustomer ? TRANSITION_REVIEW_1_BY_CUSTOMER : TRANSITION_REVIEW_1_BY_PROVIDER;\nexport const getReview2Transition = isCustomer => isCustomer ? TRANSITION_REVIEW_2_BY_CUSTOMER : TRANSITION_REVIEW_2_BY_PROVIDER; // Check if a transition is the kind that should be rendered\n// when showing transition history (e.g. ActivityFeed)\n// The first transition and most of the expiration transitions made by system are not relevant\n\nexport const isRelevantPastTransition = transition => {\n  return [TRANSITION_CONFIRM_PAYMENT, TRANSITION_AUTO_CANCEL, TRANSITION_CANCEL, TRANSITION_MARK_RECEIVED_FROM_PURCHASED, TRANSITION_MARK_DELIVERED, TRANSITION_DISPUTE, TRANSITION_MARK_RECEIVED, TRANSITION_AUTO_MARK_RECEIVED, TRANSITION_MARK_RECEIVED_FROM_DISPUTED, TRANSITION_AUTO_CANCEL_FROM_DISPUTED, TRANSITION_CANCEL_FROM_DISPUTED, TRANSITION_REVIEW_1_BY_CUSTOMER, TRANSITION_REVIEW_1_BY_PROVIDER, TRANSITION_REVIEW_2_BY_CUSTOMER, TRANSITION_REVIEW_2_BY_PROVIDER].includes(transition);\n};\nexport const isCustomerReview = transition => {\n  return [TRANSITION_REVIEW_1_BY_CUSTOMER, TRANSITION_REVIEW_2_BY_CUSTOMER].includes(transition);\n};\nexport const isProviderReview = transition => {\n  return [TRANSITION_REVIEW_1_BY_PROVIDER, TRANSITION_REVIEW_2_BY_PROVIDER].includes(transition);\n};\nexport const getUserTxRole = (currentUserId, transaction) => {\n  const tx = ensureTransaction(transaction);\n  const customer = tx.customer;\n\n  if (currentUserId && currentUserId.uuid && tx.id && customer.id) {\n    // user can be either customer or provider\n    return currentUserId.uuid === customer.id.uuid ? TX_TRANSITION_ACTOR_CUSTOMER : TX_TRANSITION_ACTOR_PROVIDER;\n  } else {\n    throw new Error(`Parameters for \"userIsCustomer\" function were wrong.\n      currentUserId: ${currentUserId}, transaction: ${transaction}`);\n  }\n};\nexport const txRoleIsProvider = userRole => userRole === TX_TRANSITION_ACTOR_PROVIDER;\nexport const txRoleIsCustomer = userRole => userRole === TX_TRANSITION_ACTOR_CUSTOMER; // Check if the given transition is privileged.\n//\n// Privileged transitions need to be handled from a secure context,\n// i.e. the backend. This helper is used to check if the transition\n// should go through the local API endpoints, or if using JS SDK is\n// enough.\n\nexport const isPrivileged = transition => {\n  return [TRANSITION_REQUEST_PAYMENT, TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY].includes(transition);\n};\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"TRANSITIONS$getTransitions(statesFromStateDescription(stateDescription)).map\");\n$RefreshReg$(_c2, \"TRANSITIONS\");","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/transaction.js"],"names":["ensureTransaction","TRANSITION_REQUEST_PAYMENT","TRANSITION_ENQUIRE","TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY","TRANSITION_CONFIRM_PAYMENT","TRANSITION_EXPIRE_PAYMENT","TRANSITION_MARK_DELIVERED","TRANSITION_MARK_RECEIVED_FROM_PURCHASED","TRANSITION_AUTO_CANCEL","TRANSITION_CANCEL","TRANSITION_MARK_RECEIVED","TRANSITION_AUTO_MARK_RECEIVED","TRANSITION_DISPUTE","TRANSITION_AUTO_CANCEL_FROM_DISPUTED","TRANSITION_CANCEL_FROM_DISPUTED","TRANSITION_MARK_RECEIVED_FROM_DISPUTED","TRANSITION_AUTO_COMPLETE","TRANSITION_REVIEW_1_BY_PROVIDER","TRANSITION_REVIEW_2_BY_PROVIDER","TRANSITION_REVIEW_1_BY_CUSTOMER","TRANSITION_REVIEW_2_BY_CUSTOMER","TRANSITION_EXPIRE_CUSTOMER_REVIEW_PERIOD","TRANSITION_EXPIRE_PROVIDER_REVIEW_PERIOD","TRANSITION_EXPIRE_REVIEW_PERIOD","TX_TRANSITION_ACTOR_CUSTOMER","TX_TRANSITION_ACTOR_PROVIDER","TX_TRANSITION_ACTOR_SYSTEM","TX_TRANSITION_ACTOR_OPERATOR","TX_TRANSITION_ACTORS","STATE_INITIAL","STATE_ENQUIRY","STATE_PENDING_PAYMENT","STATE_PAYMENT_EXPIRED","STATE_PURCHASED","STATE_DELIVERED","STATE_RECEIVED","STATE_DISPUTED","STATE_CANCELED","STATE_COMPLETED","STATE_REVIEWED","STATE_REVIEWED_BY_CUSTOMER","STATE_REVIEWED_BY_PROVIDER","stateDescription","id","initial","states","on","type","statesFromStateDescription","description","getTransitions","stateNames","Object","keys","transitionsReducer","transitionArray","name","stateTransitions","transitionKeys","map","key","value","reduce","TRANSITIONS","t","getTransitionsToStateFn","stateDesc","state","filter","getTransitionsToState","transitionsToRequested","txLastTransition","tx","attributes","lastTransition","txIsEnquired","includes","txIsPaymentPending","txIsPaymentExpired","txIsPurchased","txIsCanceled","txIsDelivered","txIsDisputed","txIsReceived","txIsCompleted","txIsReviewedByCustomer","txIsReviewedByProvider","firstReviewTransitions","txIsInFirstReview","txIsInFirstReviewBy","isCustomer","txIsReviewed","txTransitions","transitions","hasPassedTransition","transitionName","find","transition","hasPassedStateFn","length","txHasPassedPaymentPending","txHasBeenReceived","transitionIsReviewed","transitionIsFirstReviewedBy","getReview1Transition","getReview2Transition","isRelevantPastTransition","isCustomerReview","isProviderReview","getUserTxRole","currentUserId","transaction","customer","uuid","Error","txRoleIsProvider","userRole","txRoleIsCustomer","isPrivileged"],"mappings":"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","sourcesContent":["import { ensureTransaction } from './data';\r\n\r\n/**\r\n * Transitions\r\n *\r\n * These strings must sync with values defined in Flex API,\r\n * since transaction objects given by API contain info about last transitions.\r\n * All the actions in API side happen in transitions,\r\n * so we need to understand what those strings mean.\r\n */\r\n\r\n// When a customer makes an order for a listing, a transaction is\r\n// created with the initial request-payment transition.\r\n// At this transition a PaymentIntent is created by Marketplace API.\r\n// After this transition, the actual payment must be made on client-side directly to Stripe.\r\nexport const TRANSITION_REQUEST_PAYMENT = 'transition/request-payment';\r\n\r\n// A customer can also initiate a transaction with an enquiry, and\r\n// then transition that with a request.\r\nexport const TRANSITION_ENQUIRE = 'transition/enquire';\r\nexport const TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY = 'transition/request-payment-after-enquiry';\r\n\r\n// Stripe SDK might need to ask 3D security from customer, in a separate front-end step.\r\n// Therefore we need to make another transition to Marketplace API,\r\n// to tell that the payment is confirmed.\r\nexport const TRANSITION_CONFIRM_PAYMENT = 'transition/confirm-payment';\r\n\r\n// If the payment is not confirmed in the time limit set in transaction process (by default 15min)\r\n// the transaction will expire automatically.\r\nexport const TRANSITION_EXPIRE_PAYMENT = 'transition/expire-payment';\r\n\r\n// Provider can mark the product shipped/delivered\r\nexport const TRANSITION_MARK_DELIVERED = 'transition/mark-delivered';\r\n\r\n// Customer can mark the product received (e.g. picked up from provider)\r\nexport const TRANSITION_MARK_RECEIVED_FROM_PURCHASED = 'transition/mark-received-from-purchased';\r\n\r\n// Automatic cancellation happens if none marks the delivery happened\r\nexport const TRANSITION_AUTO_CANCEL = 'transition/auto-cancel';\r\n\r\n// Operator can cancel the purchase before product has been marked as delivered / received\r\nexport const TRANSITION_CANCEL = 'transition/cancel';\r\n\r\n// If provider has marked the product delivered (e.g. shipped),\r\n// customer can then mark the product received\r\nexport const TRANSITION_MARK_RECEIVED = 'transition/mark-received';\r\n\r\n// If customer doesn't mark the product received manually, it can happen automatically\r\nexport const TRANSITION_AUTO_MARK_RECEIVED = 'transition/auto-mark-received';\r\n\r\n// When provider has marked the product delivered, customer can dispute the transaction\r\nexport const TRANSITION_DISPUTE = 'transition/dispute';\r\n\r\n// If nothing is done to disputed transaction it ends up to Canceled state\r\nexport const TRANSITION_AUTO_CANCEL_FROM_DISPUTED = 'transition/auto-cancel-from-disputed';\r\n\r\n// Operator can cancel disputed transaction manually\r\nexport const TRANSITION_CANCEL_FROM_DISPUTED = 'transition/cancel-from-disputed';\r\n\r\n// Operator can mark the disputed transaction as received\r\nexport const TRANSITION_MARK_RECEIVED_FROM_DISPUTED = 'transition/mark-received-from-disputed';\r\n\r\n// System moves transaction automatically from received state to complete state\r\n// This makes it possible to to add notifications to that single transition.\r\nexport const TRANSITION_AUTO_COMPLETE = 'transition/auto-complete';\r\n\r\n// Reviews are given through transaction transitions. Review 1 can be\r\n// by provider or customer, and review 2 will be the other party of\r\n// the transaction.\r\nexport const TRANSITION_REVIEW_1_BY_PROVIDER = 'transition/review-1-by-provider';\r\nexport const TRANSITION_REVIEW_2_BY_PROVIDER = 'transition/review-2-by-provider';\r\nexport const TRANSITION_REVIEW_1_BY_CUSTOMER = 'transition/review-1-by-customer';\r\nexport const TRANSITION_REVIEW_2_BY_CUSTOMER = 'transition/review-2-by-customer';\r\nexport const TRANSITION_EXPIRE_CUSTOMER_REVIEW_PERIOD = 'transition/expire-customer-review-period';\r\nexport const TRANSITION_EXPIRE_PROVIDER_REVIEW_PERIOD = 'transition/expire-provider-review-period';\r\nexport const TRANSITION_EXPIRE_REVIEW_PERIOD = 'transition/expire-review-period';\r\n\r\n/**\r\n * Actors\r\n *\r\n * There are 4 different actors that might initiate transitions:\r\n */\r\n\r\n// Roles of actors that perform transaction transitions\r\nexport const TX_TRANSITION_ACTOR_CUSTOMER = 'customer';\r\nexport const TX_TRANSITION_ACTOR_PROVIDER = 'provider';\r\nexport const TX_TRANSITION_ACTOR_SYSTEM = 'system';\r\nexport const TX_TRANSITION_ACTOR_OPERATOR = 'operator';\r\n\r\nexport const TX_TRANSITION_ACTORS = [\r\n  TX_TRANSITION_ACTOR_CUSTOMER,\r\n  TX_TRANSITION_ACTOR_PROVIDER,\r\n  TX_TRANSITION_ACTOR_SYSTEM,\r\n  TX_TRANSITION_ACTOR_OPERATOR,\r\n];\r\n\r\n/**\r\n * States\r\n *\r\n * These constants are only for making it clear how transitions work together.\r\n * You should not use these constants outside of this file.\r\n *\r\n * Note: these states are not in sync with states used transaction process definitions\r\n *       in Marketplace API. Only last transitions are passed along transaction object.\r\n */\r\nconst STATE_INITIAL = 'initial';\r\nconst STATE_ENQUIRY = 'enquiry';\r\nconst STATE_PENDING_PAYMENT = 'pending-payment';\r\nconst STATE_PAYMENT_EXPIRED = 'payment-expired';\r\nconst STATE_PURCHASED = 'purchased';\r\nconst STATE_DELIVERED = 'delivered';\r\nconst STATE_RECEIVED = 'received';\r\nconst STATE_DISPUTED = 'disputed';\r\nconst STATE_CANCELED = 'canceled';\r\nconst STATE_COMPLETED = 'completed';\r\nconst STATE_REVIEWED = 'reviewed';\r\nconst STATE_REVIEWED_BY_CUSTOMER = 'reviewed-by-customer';\r\nconst STATE_REVIEWED_BY_PROVIDER = 'reviewed-by-provider';\r\n\r\n/**\r\n * Description of transaction process\r\n *\r\n * You should keep this in sync with transaction process defined in Marketplace API\r\n *\r\n * Note: we don't use yet any state machine library,\r\n *       but this description format is following Xstate (FSM library)\r\n *       https://xstate.js.org/docs/\r\n */\r\nconst stateDescription = {\r\n  // id is defined only to support Xstate format.\r\n  // However if you have multiple transaction processes defined,\r\n  // it is best to keep them in sync with transaction process aliases.\r\n  id: 'flex-product-default-process/release-1',\r\n\r\n  // This 'initial' state is a starting point for new transaction\r\n  initial: STATE_INITIAL,\r\n\r\n  // States\r\n  states: {\r\n    [STATE_INITIAL]: {\r\n      on: {\r\n        [TRANSITION_ENQUIRE]: STATE_ENQUIRY,\r\n        [TRANSITION_REQUEST_PAYMENT]: STATE_PENDING_PAYMENT,\r\n      },\r\n    },\r\n    [STATE_ENQUIRY]: {\r\n      on: {\r\n        [TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY]: STATE_PENDING_PAYMENT,\r\n      },\r\n    },\r\n\r\n    [STATE_PENDING_PAYMENT]: {\r\n      on: {\r\n        [TRANSITION_EXPIRE_PAYMENT]: STATE_PAYMENT_EXPIRED,\r\n        [TRANSITION_CONFIRM_PAYMENT]: STATE_PURCHASED,\r\n      },\r\n    },\r\n\r\n    [STATE_PAYMENT_EXPIRED]: {},\r\n    [STATE_PURCHASED]: {\r\n      on: {\r\n        [TRANSITION_MARK_DELIVERED]: STATE_DELIVERED,\r\n        [TRANSITION_MARK_RECEIVED_FROM_PURCHASED]: STATE_RECEIVED,\r\n        [TRANSITION_AUTO_CANCEL]: STATE_CANCELED,\r\n        [TRANSITION_CANCEL]: STATE_CANCELED,\r\n      },\r\n    },\r\n\r\n    [STATE_CANCELED]: {},\r\n\r\n    [STATE_DELIVERED]: {\r\n      on: {\r\n        [TRANSITION_MARK_RECEIVED]: STATE_RECEIVED,\r\n        [TRANSITION_AUTO_MARK_RECEIVED]: STATE_RECEIVED,\r\n        [TRANSITION_DISPUTE]: STATE_DISPUTED,\r\n      },\r\n    },\r\n\r\n    [STATE_DISPUTED]: {\r\n      on: {\r\n        [TRANSITION_AUTO_CANCEL_FROM_DISPUTED]: STATE_CANCELED,\r\n        [TRANSITION_CANCEL_FROM_DISPUTED]: STATE_CANCELED,\r\n        [TRANSITION_MARK_RECEIVED_FROM_DISPUTED]: STATE_RECEIVED,\r\n      },\r\n    },\r\n\r\n    [STATE_RECEIVED]: {\r\n      on: {\r\n        [TRANSITION_AUTO_COMPLETE]: STATE_COMPLETED,\r\n      },\r\n    },\r\n\r\n    [STATE_COMPLETED]: {\r\n      on: {\r\n        [TRANSITION_EXPIRE_REVIEW_PERIOD]: STATE_REVIEWED,\r\n        [TRANSITION_REVIEW_1_BY_CUSTOMER]: STATE_REVIEWED_BY_CUSTOMER,\r\n        [TRANSITION_REVIEW_1_BY_PROVIDER]: STATE_REVIEWED_BY_PROVIDER,\r\n      },\r\n    },\r\n\r\n    [STATE_REVIEWED_BY_CUSTOMER]: {\r\n      on: {\r\n        [TRANSITION_REVIEW_2_BY_PROVIDER]: STATE_REVIEWED,\r\n        [TRANSITION_EXPIRE_PROVIDER_REVIEW_PERIOD]: STATE_REVIEWED,\r\n      },\r\n    },\r\n    [STATE_REVIEWED_BY_PROVIDER]: {\r\n      on: {\r\n        [TRANSITION_REVIEW_2_BY_CUSTOMER]: STATE_REVIEWED,\r\n        [TRANSITION_EXPIRE_CUSTOMER_REVIEW_PERIOD]: STATE_REVIEWED,\r\n      },\r\n    },\r\n    [STATE_REVIEWED]: { type: 'final' },\r\n  },\r\n};\r\n\r\n// Note: currently we assume that state description doesn't contain nested states.\r\nconst statesFromStateDescription = description => description.states || {};\r\n\r\n// Get all the transitions from states object in an array\r\nconst getTransitions = states => {\r\n  const stateNames = Object.keys(states);\r\n\r\n  const transitionsReducer = (transitionArray, name) => {\r\n    const stateTransitions = states[name] && states[name].on;\r\n    const transitionKeys = stateTransitions ? Object.keys(stateTransitions) : [];\r\n    return [\r\n      ...transitionArray,\r\n      ...transitionKeys.map(key => ({ key, value: stateTransitions[key] })),\r\n    ];\r\n  };\r\n\r\n  return stateNames.reduce(transitionsReducer, []);\r\n};\r\n\r\n// This is a list of all the transitions that this app should be able to handle.\r\nexport const TRANSITIONS = getTransitions(statesFromStateDescription(stateDescription)).map(\r\n  t => t.key\r\n);\r\n\r\n// This function returns a function that has given stateDesc in scope chain.\r\nconst getTransitionsToStateFn = stateDesc => state =>\r\n  getTransitions(statesFromStateDescription(stateDesc))\r\n    .filter(t => t.value === state)\r\n    .map(t => t.key);\r\n\r\n// Get all the transitions that lead to specified state.\r\nconst getTransitionsToState = getTransitionsToStateFn(stateDescription);\r\n\r\n// This is needed to fetch transactions that need response from provider.\r\n// I.e. transactions which provider needs to accept or decline\r\nexport const transitionsToRequested = getTransitionsToState(STATE_PURCHASED);\r\n\r\n/**\r\n * Helper functions to figure out if transaction is in a specific state.\r\n * State is based on lastTransition given by transaction object and state description.\r\n */\r\n\r\nconst txLastTransition = tx => ensureTransaction(tx).attributes.lastTransition;\r\n\r\nexport const txIsEnquired = tx =>\r\n  getTransitionsToState(STATE_ENQUIRY).includes(txLastTransition(tx));\r\n\r\nexport const txIsPaymentPending = tx =>\r\n  getTransitionsToState(STATE_PENDING_PAYMENT).includes(txLastTransition(tx));\r\n\r\nexport const txIsPaymentExpired = tx =>\r\n  getTransitionsToState(STATE_PAYMENT_EXPIRED).includes(txLastTransition(tx));\r\n\r\nexport const txIsPurchased = tx =>\r\n  getTransitionsToState(STATE_PURCHASED).includes(txLastTransition(tx));\r\n\r\nexport const txIsCanceled = tx =>\r\n  getTransitionsToState(STATE_CANCELED).includes(txLastTransition(tx));\r\n\r\nexport const txIsDelivered = tx =>\r\n  getTransitionsToState(STATE_DELIVERED).includes(txLastTransition(tx));\r\n\r\nexport const txIsDisputed = tx =>\r\n  getTransitionsToState(STATE_DISPUTED).includes(txLastTransition(tx));\r\n\r\nexport const txIsReceived = tx =>\r\n  getTransitionsToState(STATE_RECEIVED).includes(txLastTransition(tx));\r\n\r\nexport const txIsCompleted = tx =>\r\n  getTransitionsToState(STATE_COMPLETED).includes(txLastTransition(tx));\r\n\r\nexport const txIsReviewedByCustomer = tx =>\r\n  getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(txLastTransition(tx));\r\n\r\nexport const txIsReviewedByProvider = tx =>\r\n  getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(txLastTransition(tx));\r\n\r\nconst firstReviewTransitions = [\r\n  ...getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER),\r\n  ...getTransitionsToState(STATE_REVIEWED_BY_PROVIDER),\r\n];\r\nexport const txIsInFirstReview = tx => firstReviewTransitions.includes(txLastTransition(tx));\r\n\r\nexport const txIsInFirstReviewBy = (tx, isCustomer) =>\r\n  isCustomer\r\n    ? getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(txLastTransition(tx))\r\n    : getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(txLastTransition(tx));\r\n\r\nexport const txIsReviewed = tx =>\r\n  getTransitionsToState(STATE_REVIEWED).includes(txLastTransition(tx));\r\n\r\n/**\r\n * Helper functions to figure out if transaction has passed a given state.\r\n * This is based on transitions history given by transaction object.\r\n */\r\n\r\nconst txTransitions = tx => ensureTransaction(tx).attributes.transitions || [];\r\nconst hasPassedTransition = (transitionName, tx) =>\r\n  !!txTransitions(tx).find(t => t.transition === transitionName);\r\n\r\nconst hasPassedStateFn = state => tx =>\r\n  getTransitionsToState(state).filter(t => hasPassedTransition(t, tx)).length > 0;\r\n\r\n// Helper function to check if the transaction has passed a certain state\r\nexport const txHasPassedPaymentPending = hasPassedStateFn(STATE_PENDING_PAYMENT);\r\nexport const txHasBeenReceived = hasPassedStateFn(STATE_RECEIVED);\r\n\r\n/**\r\n * Other transaction related utility functions\r\n */\r\n\r\nexport const transitionIsReviewed = transition =>\r\n  getTransitionsToState(STATE_REVIEWED).includes(transition);\r\n\r\nexport const transitionIsFirstReviewedBy = (transition, isCustomer) =>\r\n  isCustomer\r\n    ? getTransitionsToState(STATE_REVIEWED_BY_CUSTOMER).includes(transition)\r\n    : getTransitionsToState(STATE_REVIEWED_BY_PROVIDER).includes(transition);\r\n\r\nexport const getReview1Transition = isCustomer =>\r\n  isCustomer ? TRANSITION_REVIEW_1_BY_CUSTOMER : TRANSITION_REVIEW_1_BY_PROVIDER;\r\n\r\nexport const getReview2Transition = isCustomer =>\r\n  isCustomer ? TRANSITION_REVIEW_2_BY_CUSTOMER : TRANSITION_REVIEW_2_BY_PROVIDER;\r\n\r\n// Check if a transition is the kind that should be rendered\r\n// when showing transition history (e.g. ActivityFeed)\r\n// The first transition and most of the expiration transitions made by system are not relevant\r\nexport const isRelevantPastTransition = transition => {\r\n  return [\r\n    TRANSITION_CONFIRM_PAYMENT,\r\n    TRANSITION_AUTO_CANCEL,\r\n    TRANSITION_CANCEL,\r\n    TRANSITION_MARK_RECEIVED_FROM_PURCHASED,\r\n    TRANSITION_MARK_DELIVERED,\r\n    TRANSITION_DISPUTE,\r\n    TRANSITION_MARK_RECEIVED,\r\n    TRANSITION_AUTO_MARK_RECEIVED,\r\n    TRANSITION_MARK_RECEIVED_FROM_DISPUTED,\r\n    TRANSITION_AUTO_CANCEL_FROM_DISPUTED,\r\n    TRANSITION_CANCEL_FROM_DISPUTED,\r\n    TRANSITION_REVIEW_1_BY_CUSTOMER,\r\n    TRANSITION_REVIEW_1_BY_PROVIDER,\r\n    TRANSITION_REVIEW_2_BY_CUSTOMER,\r\n    TRANSITION_REVIEW_2_BY_PROVIDER,\r\n  ].includes(transition);\r\n};\r\n\r\nexport const isCustomerReview = transition => {\r\n  return [TRANSITION_REVIEW_1_BY_CUSTOMER, TRANSITION_REVIEW_2_BY_CUSTOMER].includes(transition);\r\n};\r\n\r\nexport const isProviderReview = transition => {\r\n  return [TRANSITION_REVIEW_1_BY_PROVIDER, TRANSITION_REVIEW_2_BY_PROVIDER].includes(transition);\r\n};\r\n\r\nexport const getUserTxRole = (currentUserId, transaction) => {\r\n  const tx = ensureTransaction(transaction);\r\n  const customer = tx.customer;\r\n  if (currentUserId && currentUserId.uuid && tx.id && customer.id) {\r\n    // user can be either customer or provider\r\n    return currentUserId.uuid === customer.id.uuid\r\n      ? TX_TRANSITION_ACTOR_CUSTOMER\r\n      : TX_TRANSITION_ACTOR_PROVIDER;\r\n  } else {\r\n    throw new Error(`Parameters for \"userIsCustomer\" function were wrong.\r\n      currentUserId: ${currentUserId}, transaction: ${transaction}`);\r\n  }\r\n};\r\n\r\nexport const txRoleIsProvider = userRole => userRole === TX_TRANSITION_ACTOR_PROVIDER;\r\nexport const txRoleIsCustomer = userRole => userRole === TX_TRANSITION_ACTOR_CUSTOMER;\r\n\r\n// Check if the given transition is privileged.\r\n//\r\n// Privileged transitions need to be handled from a secure context,\r\n// i.e. the backend. This helper is used to check if the transition\r\n// should go through the local API endpoints, or if using JS SDK is\r\n// enough.\r\nexport const isPrivileged = transition => {\r\n  return [TRANSITION_REQUEST_PAYMENT, TRANSITION_REQUEST_PAYMENT_AFTER_ENQUIRY].includes(\r\n    transition\r\n  );\r\n};\r\n"]},"metadata":{},"sourceType":"module"}