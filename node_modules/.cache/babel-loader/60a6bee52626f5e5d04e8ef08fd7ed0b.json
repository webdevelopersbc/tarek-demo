{"ast":null,"code":"import intersection from 'lodash/intersection';\nimport config from '../../config';\nimport { createResourceLocatorString } from '../../util/routes';\nimport { parseSelectFilterOptions, isOriginInUse } from '../../util/search';\nimport { createSlug } from '../../util/urlHelpers';\nimport routeConfiguration from '../../routing/routeConfiguration';\n\nconst flatten = (acc, val) => acc.concat(val);\n/**\r\n * Validates a filter search param agains a filters configuration.\r\n *\r\n * All invalid param names and values are dropped\r\n *\r\n * @param {String} queryParamName Search parameter name\r\n * @param {Object} paramValue Search parameter value\r\n * @param {Object} filters Filters configuration\r\n */\n\n\nexport const validURLParamForExtendedData = (queryParamName, paramValueRaw, filters) => {\n  // Resolve configuration for this filter\n  const filterConfig = filters.find(f => {\n    const isArray = Array.isArray(f.queryParamNames);\n    return isArray ? f.queryParamNames.includes(queryParamName) : f.queryParamNames === queryParamName;\n  });\n  const paramValue = paramValueRaw.toString();\n\n  if (filterConfig) {\n    const {\n      min,\n      max\n    } = filterConfig.config || {};\n\n    if (['SelectSingleFilter', 'SelectMultipleFilter'].includes(filterConfig.type)) {\n      // Pick valid select options only\n      const allowedValues = filterConfig.config.options.map(o => o.key);\n      const searchMode = filterConfig.config.searchMode;\n      const isSchemaTypeMultiEnum = filterConfig.config.schemaType === 'multi-enum';\n      const valueArray = parseSelectFilterOptions(paramValue);\n      const validValues = intersection(valueArray, allowedValues).join(',');\n      return validValues.length > 0 ? {\n        [queryParamName]: isSchemaTypeMultiEnum && searchMode ? `${searchMode}:${validValues}` : validValues\n      } : {};\n    } else if (filterConfig.type === 'PriceFilter') {\n      // Restrict price range to correct min & max\n      const valueArray = paramValue ? paramValue.split(',') : [];\n      const validValues = valueArray.map(v => {\n        return v < min ? min : v > max ? max : v;\n      });\n      return validValues.length === 2 ? {\n        [queryParamName]: validValues.join(',')\n      } : {};\n    } else if (filterConfig) {\n      // Generic filter - remove empty params\n      return paramValue.length > 0 ? {\n        [queryParamName]: paramValue\n      } : {};\n    }\n  }\n\n  return {};\n};\n/**\r\n * Checks filter param value validity.\r\n *\r\n * Non-filter params are dropped.\r\n *\r\n * @param {Object} params Search params\r\n * @param {Object} filters Filters configuration\r\n */\n\nexport const validFilterParams = (params, filters) => {\n  const filterParamNames = filters.map(f => f.queryParamNames).reduce(flatten, []);\n  const paramEntries = Object.entries(params);\n  return paramEntries.reduce((validParams, entry) => {\n    const [paramName, paramValue] = entry;\n    return filterParamNames.includes(paramName) ? { ...validParams,\n      ...validURLParamForExtendedData(paramName, paramValue, filters)\n    } : { ...validParams\n    };\n  }, {});\n};\n/**\r\n * Checks filter param value validity.\r\n *\r\n * Non-filter params are returned as they are.\r\n *\r\n * @param {Object} params Search params\r\n * @param {Object} filters Filters configuration\r\n */\n\nexport const validURLParamsForExtendedData = (params, filters) => {\n  const filterParamNames = filters.map(f => f.queryParamNames).reduce(flatten, []);\n  const paramEntries = Object.entries(params);\n  return paramEntries.reduce((validParams, entry) => {\n    const [paramName, paramValue] = entry;\n    return filterParamNames.includes(paramName) ? { ...validParams,\n      ...validURLParamForExtendedData(paramName, paramValue, filters)\n    } : { ...validParams,\n      [paramName]: paramValue\n    };\n  }, {});\n}; // extract search parameters, including a custom URL params\n// which are validated by mapping the values to marketplace custom config.\n\nexport const pickSearchParamsOnly = (params, filters, sortConfig) => {\n  const {\n    address,\n    origin,\n    bounds,\n    ...rest\n  } = params || {};\n  const boundsMaybe = bounds ? {\n    bounds\n  } : {};\n  const originMaybe = isOriginInUse(config) && origin ? {\n    origin\n  } : {};\n  const filterParams = validFilterParams(rest, filters);\n  const sort = rest[sortConfig.queryParamName];\n  const sortMaybe = sort ? {\n    sort\n  } : {};\n  return { ...boundsMaybe,\n    ...originMaybe,\n    ...filterParams,\n    ...sortMaybe\n  };\n};\nexport const createSearchResultSchema = (listings, mainSearchData, intl) => {\n  // Schema for search engines (helps them to understand what this page is about)\n  // http://schema.org\n  // We are using JSON-LD format\n  const siteTitle = config.siteTitle;\n  const {\n    address,\n    keywords\n  } = mainSearchData;\n  const keywordsMaybe = keywords ? `\"${keywords}\"` : null;\n  const searchTitle = address || keywordsMaybe || intl.formatMessage({\n    id: 'SearchPage.schemaForSearch'\n  });\n  const schemaDescription = intl.formatMessage({\n    id: 'SearchPage.schemaDescription'\n  });\n  const schemaTitle = intl.formatMessage({\n    id: 'SearchPage.schemaTitle'\n  }, {\n    searchTitle,\n    siteTitle\n  });\n  const schemaListings = listings.map((l, i) => {\n    const title = l.attributes.title;\n    const pathToItem = createResourceLocatorString('ListingPage', routeConfiguration(), {\n      id: l.id.uuid,\n      slug: createSlug(title)\n    });\n    return {\n      '@type': 'ListItem',\n      position: i,\n      url: `${config.canonicalRootURL}${pathToItem}`,\n      name: title\n    };\n  });\n  const schemaMainEntity = JSON.stringify({\n    '@type': 'ItemList',\n    name: searchTitle,\n    itemListOrder: 'http://schema.org/ItemListOrderAscending',\n    itemListElement: schemaListings\n  });\n  return {\n    title: schemaTitle,\n    description: schemaDescription,\n    schema: {\n      '@context': 'http://schema.org',\n      '@type': 'SearchResultsPage',\n      description: schemaDescription,\n      name: schemaTitle,\n      mainEntity: [schemaMainEntity]\n    }\n  };\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/containers/SearchPage/SearchPage.helpers.js"],"names":["intersection","config","createResourceLocatorString","parseSelectFilterOptions","isOriginInUse","createSlug","routeConfiguration","flatten","acc","val","concat","validURLParamForExtendedData","queryParamName","paramValueRaw","filters","filterConfig","find","f","isArray","Array","queryParamNames","includes","paramValue","toString","min","max","type","allowedValues","options","map","o","key","searchMode","isSchemaTypeMultiEnum","schemaType","valueArray","validValues","join","length","split","v","validFilterParams","params","filterParamNames","reduce","paramEntries","Object","entries","validParams","entry","paramName","validURLParamsForExtendedData","pickSearchParamsOnly","sortConfig","address","origin","bounds","rest","boundsMaybe","originMaybe","filterParams","sort","sortMaybe","createSearchResultSchema","listings","mainSearchData","intl","siteTitle","keywords","keywordsMaybe","searchTitle","formatMessage","id","schemaDescription","schemaTitle","schemaListings","l","i","title","attributes","pathToItem","uuid","slug","position","url","canonicalRootURL","name","schemaMainEntity","JSON","stringify","itemListOrder","itemListElement","description","schema","mainEntity"],"mappings":"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","sourcesContent":["import intersection from 'lodash/intersection';\r\nimport config from '../../config';\r\nimport { createResourceLocatorString } from '../../util/routes';\r\nimport { parseSelectFilterOptions, isOriginInUse } from '../../util/search';\r\nimport { createSlug } from '../../util/urlHelpers';\r\nimport routeConfiguration from '../../routing/routeConfiguration';\r\n\r\nconst flatten = (acc, val) => acc.concat(val);\r\n\r\n/**\r\n * Validates a filter search param agains a filters configuration.\r\n *\r\n * All invalid param names and values are dropped\r\n *\r\n * @param {String} queryParamName Search parameter name\r\n * @param {Object} paramValue Search parameter value\r\n * @param {Object} filters Filters configuration\r\n */\r\nexport const validURLParamForExtendedData = (queryParamName, paramValueRaw, filters) => {\r\n  // Resolve configuration for this filter\r\n  const filterConfig = filters.find(f => {\r\n    const isArray = Array.isArray(f.queryParamNames);\r\n    return isArray\r\n      ? f.queryParamNames.includes(queryParamName)\r\n      : f.queryParamNames === queryParamName;\r\n  });\r\n\r\n  const paramValue = paramValueRaw.toString();\r\n\r\n  if (filterConfig) {\r\n    const { min, max } = filterConfig.config || {};\r\n\r\n    if (['SelectSingleFilter', 'SelectMultipleFilter'].includes(filterConfig.type)) {\r\n      // Pick valid select options only\r\n      const allowedValues = filterConfig.config.options.map(o => o.key);\r\n      const searchMode = filterConfig.config.searchMode;\r\n      const isSchemaTypeMultiEnum = filterConfig.config.schemaType === 'multi-enum';\r\n      const valueArray = parseSelectFilterOptions(paramValue);\r\n      const validValues = intersection(valueArray, allowedValues).join(',');\r\n\r\n      return validValues.length > 0\r\n        ? {\r\n            [queryParamName]:\r\n              isSchemaTypeMultiEnum && searchMode ? `${searchMode}:${validValues}` : validValues,\r\n          }\r\n        : {};\r\n    } else if (filterConfig.type === 'PriceFilter') {\r\n      // Restrict price range to correct min & max\r\n      const valueArray = paramValue ? paramValue.split(',') : [];\r\n      const validValues = valueArray.map(v => {\r\n        return v < min ? min : v > max ? max : v;\r\n      });\r\n      return validValues.length === 2 ? { [queryParamName]: validValues.join(',') } : {};\r\n    } else if (filterConfig) {\r\n      // Generic filter - remove empty params\r\n      return paramValue.length > 0 ? { [queryParamName]: paramValue } : {};\r\n    }\r\n  }\r\n  return {};\r\n};\r\n\r\n/**\r\n * Checks filter param value validity.\r\n *\r\n * Non-filter params are dropped.\r\n *\r\n * @param {Object} params Search params\r\n * @param {Object} filters Filters configuration\r\n */\r\nexport const validFilterParams = (params, filters) => {\r\n  const filterParamNames = filters.map(f => f.queryParamNames).reduce(flatten, []);\r\n  const paramEntries = Object.entries(params);\r\n\r\n  return paramEntries.reduce((validParams, entry) => {\r\n    const [paramName, paramValue] = entry;\r\n\r\n    return filterParamNames.includes(paramName)\r\n      ? {\r\n          ...validParams,\r\n          ...validURLParamForExtendedData(paramName, paramValue, filters),\r\n        }\r\n      : { ...validParams };\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Checks filter param value validity.\r\n *\r\n * Non-filter params are returned as they are.\r\n *\r\n * @param {Object} params Search params\r\n * @param {Object} filters Filters configuration\r\n */\r\nexport const validURLParamsForExtendedData = (params, filters) => {\r\n  const filterParamNames = filters.map(f => f.queryParamNames).reduce(flatten, []);\r\n  const paramEntries = Object.entries(params);\r\n\r\n  return paramEntries.reduce((validParams, entry) => {\r\n    const [paramName, paramValue] = entry;\r\n\r\n    return filterParamNames.includes(paramName)\r\n      ? {\r\n          ...validParams,\r\n          ...validURLParamForExtendedData(paramName, paramValue, filters),\r\n        }\r\n      : { ...validParams, [paramName]: paramValue };\r\n  }, {});\r\n};\r\n\r\n// extract search parameters, including a custom URL params\r\n// which are validated by mapping the values to marketplace custom config.\r\nexport const pickSearchParamsOnly = (params, filters, sortConfig) => {\r\n  const { address, origin, bounds, ...rest } = params || {};\r\n  const boundsMaybe = bounds ? { bounds } : {};\r\n  const originMaybe = isOriginInUse(config) && origin ? { origin } : {};\r\n  const filterParams = validFilterParams(rest, filters);\r\n  const sort = rest[sortConfig.queryParamName];\r\n  const sortMaybe = sort ? { sort } : {};\r\n\r\n  return {\r\n    ...boundsMaybe,\r\n    ...originMaybe,\r\n    ...filterParams,\r\n    ...sortMaybe,\r\n  };\r\n};\r\n\r\nexport const createSearchResultSchema = (listings, mainSearchData, intl) => {\r\n  // Schema for search engines (helps them to understand what this page is about)\r\n  // http://schema.org\r\n  // We are using JSON-LD format\r\n  const siteTitle = config.siteTitle;\r\n  const { address, keywords } = mainSearchData;\r\n  const keywordsMaybe = keywords ? `\"${keywords}\"` : null;\r\n  const searchTitle =\r\n    address || keywordsMaybe || intl.formatMessage({ id: 'SearchPage.schemaForSearch' });\r\n  const schemaDescription = intl.formatMessage({ id: 'SearchPage.schemaDescription' });\r\n  const schemaTitle = intl.formatMessage(\r\n    { id: 'SearchPage.schemaTitle' },\r\n    { searchTitle, siteTitle }\r\n  );\r\n\r\n  const schemaListings = listings.map((l, i) => {\r\n    const title = l.attributes.title;\r\n    const pathToItem = createResourceLocatorString('ListingPage', routeConfiguration(), {\r\n      id: l.id.uuid,\r\n      slug: createSlug(title),\r\n    });\r\n    return {\r\n      '@type': 'ListItem',\r\n      position: i,\r\n      url: `${config.canonicalRootURL}${pathToItem}`,\r\n      name: title,\r\n    };\r\n  });\r\n\r\n  const schemaMainEntity = JSON.stringify({\r\n    '@type': 'ItemList',\r\n    name: searchTitle,\r\n    itemListOrder: 'http://schema.org/ItemListOrderAscending',\r\n    itemListElement: schemaListings,\r\n  });\r\n  return {\r\n    title: schemaTitle,\r\n    description: schemaDescription,\r\n    schema: {\r\n      '@context': 'http://schema.org',\r\n      '@type': 'SearchResultsPage',\r\n      description: schemaDescription,\r\n      name: schemaTitle,\r\n      mainEntity: [schemaMainEntity],\r\n    },\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}