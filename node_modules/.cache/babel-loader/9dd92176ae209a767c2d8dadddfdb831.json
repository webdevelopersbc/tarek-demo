{"ast":null,"code":"import moment from 'moment-timezone/builds/moment-timezone-with-data-10-year-range.min';\n/**\r\n * Input names for the DateRangePicker from react-dates.\r\n */\n\nexport const START_DATE = 'startDate';\nexport const END_DATE = 'endDate';\n/**\r\n * Check if the browser's DateTimeFormat API supports time zones.\r\n *\r\n * @returns {Boolean} true if the browser returns current time zone.\r\n */\n\nexport const isTimeZoneSupported = () => {\n  if (!Intl || typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {\n    return false;\n  }\n\n  const dtf = new Intl.DateTimeFormat();\n\n  if (typeof dtf === 'undefined' || typeof dtf.resolvedOptions === 'undefined') {\n    return false;\n  }\n\n  return !!dtf.resolvedOptions().timeZone;\n};\n/**\r\n * Check if the given time zone key is valid.\r\n *\r\n * @param {String} timeZone time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {Boolean} true if the browser recognizes the key.\r\n */\n\nexport const isValidTimeZone = timeZone => {\n  try {\n    new Intl.DateTimeFormat('en-US', {\n      timeZone\n    }).format();\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\r\n * Check that the given parameter is a Date object.\r\n *\r\n * @param {Date} object that should be a Date.\r\n *\r\n * @returns {boolean} true if given parameter is a Date object.\r\n */\n\nexport const isDate = d => d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\n/**\r\n * Check if the given parameters represent the same Date value (timestamps are compared)\r\n *\r\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\r\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\r\n *\r\n * @returns {boolean} true if given parameters have the same timestamp.\r\n */\n\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\n/**\r\n * Compare is dateA is after dateB\r\n *\r\n * @param {Date} dateA date instance\r\n * @param {Date} dateB date instance\r\n *\r\n * @returns {Date} true if dateA is after dateB\r\n */\n\nexport const isAfterDate = (dateA, dateB) => {\n  return moment(dateA).isAfter(moment(dateB));\n}; ////////////////////////////////////////////////////////////////////\n// Manipulate time: time-of-day between different time zones etc. //\n////////////////////////////////////////////////////////////////////\n\n/**\r\n * Returns a new date, which indicates the same time of day in a given time zone\r\n * as given date is in local time zone\r\n *\r\n * @param {Date} date\r\n * @param {String} timeZone\r\n *\r\n * @returns {Date} date in given time zone\r\n */\n\nexport const timeOfDayFromLocalToTimeZone = (date, timeZone) => {\n  return moment.tz(moment(date).format('YYYY-MM-DD HH:mm:ss'), timeZone).toDate();\n};\n/**\r\n * Returns a new date, which indicates the same time of day in a local time zone\r\n * as given date is in specified time zone\r\n *\r\n * @param {Date} date\r\n * @param {String} timeZone\r\n *\r\n * @returns {Date} date in given time zone\r\n */\n\nexport const timeOfDayFromTimeZoneToLocal = (date, timeZone) => {\n  return moment(moment(date).tz(timeZone).format('YYYY-MM-DD HH:mm:ss')).toDate();\n};\n/**\r\n * Get start of time unit (e.g. start of day)\r\n *\r\n * @param {Date} date date instance to be converted\r\n * @param {String} unit time-unit (e.g. \"day\")\r\n * @param {String} timeZone time zone id\r\n *\r\n * @returns {Date} date object converted to the start of given unit\r\n */\n\nexport const getStartOf = (date, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.startOf(unit).toDate();\n};\n/**\r\n * Adds time-units to the date\r\n *\r\n * @param {Date} date date to be manipulated\r\n * @param {int} offset offset of time-units (e.g. \"3\" days)\r\n * @param {String} unit time-unit (e.g. \"days\")\r\n * @param {String} timeZone time zone name\r\n *\r\n * @returns {Date} date with given offset added\r\n */\n\nexport const addTime = (date, offset, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.add(offset, unit).toDate();\n};\n/**\r\n * Subtract time-units from the date\r\n *\r\n * @param {Date} date date to be manipulated\r\n * @param {int} offset offset of time-units (e.g. \"3\" days)\r\n * @param {String} unit time-unit (e.g. \"days\")\r\n * @param {String} timeZone time zone name\r\n *\r\n * @returns {Date} date with given offset subtracted\r\n */\n\nexport const subtractTime = (date, offset, unit, timeZone) => {\n  const m = timeZone ? moment(date).clone().tz(timeZone) : moment(date).clone();\n  return m.subtract(offset, unit).toDate();\n}; ///////////////\n// Durations //\n///////////////\n\n/**\r\n * Calculate the number of days between the given dates.\r\n * This uses moment#diff and, therefore, it just checks,\r\n * if there are 1000x60x60x24 milliseconds between date objects.\r\n *\r\n * Note: This should not be used for checking if the local date has\r\n *       changed between \"2021-04-07 23:00\" and \"2021-04-08 05:00\".\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period. NOTE: with daily\r\n * bookings, it is expected that this date is the exclusive end date,\r\n * i.e. the last day of the booking is the previous date of this end\r\n * date.\r\n *\r\n * @throws Will throw if the end date is before the start date\r\n * @returns {Number} number of days between the given dates\r\n */\n\nexport const daysBetween = (startDate, endDate) => {\n  const days = moment(endDate).diff(startDate, 'days');\n\n  if (days < 0) {\n    throw new Error('End date cannot be before start date');\n  }\n\n  return days;\n};\n/**\r\n * Count the number of minutes between the given Date objects.\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period.\r\n *\r\n * @returns {Number} number of minutes between the given Date objects\r\n */\n\nexport const minutesBetween = (startDate, endDate) => {\n  const minutes = moment(endDate).diff(startDate, 'minutes');\n  return minutes;\n};\n/**\r\n * Calculate the difference between the given dates\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period.\r\n * @param {String} unit time unit. E.g. 'years'.\r\n * @param {String} useFloat Should return floating point numbers?\r\n *\r\n * @returns {Number} time difference between the given Date objects using given unit\r\n */\n\nexport const diffInTime = (startDate, endDate, unit, useFloat = false) => {\n  return moment(startDate).diff(endDate, unit, useFloat);\n}; ////////////////////////////\n// Parsing and formatting //\n////////////////////////////\n\nconst getTimeZoneMaybe = timeZone => {\n  if (timeZone) {\n    if (!isTimeZoneSupported()) {\n      throw new Error(`Your browser doesn't support time zones.`);\n    }\n\n    if (!isValidTimeZone(timeZone)) {\n      throw new Error(`Given time zone key (${timeZone}) is not valid.`);\n    }\n\n    return {\n      timeZone\n    };\n  }\n\n  return {};\n};\n/**\r\n * Format the given date. Printed string depends on how close the date is the current day.\r\n * E.g. \"Today, 9:10 PM\", \"Sun 6:02 PM\", \"Jul 20, 6:02 PM\", \"Jul 20 2020, 6:02 PM\"\r\n *\r\n * @param {Date} date Date to be formatted\r\n * @param {Object} intl Intl object from react-intl\r\n * @param {String} todayString translation for the current day\r\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\r\n *\r\n * @returns {String} formatted date\r\n */\n\n\nexport const formatDateWithProximity = (date, intl, todayString, opts = {}) => {\n  const paramsValid = intl && date instanceof Date && typeof todayString === 'string';\n\n  if (!paramsValid) {\n    throw new Error(`Invalid params for formatDate: (${date}, ${intl}, ${todayString})`);\n  } // If timeZone parameter is set, use it as formatting option\n\n\n  const {\n    timeZone\n  } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone); // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n\n  const now = intl.now ? moment(intl.now()) : moment(); // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n\n  if (localizedNow.isSame(date, 'day')) {\n    // e.g. \"Today, 9:10 PM\"\n    const formattedTime = intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n    return `${todayString}, ${formattedTime}`;\n  } else if (localizedNow.isSame(date, 'week')) {\n    // e.g.\n    // en-US: \"Sun 6:02 PM\"\n    // en-GB: \"Sun 18:02\"\n    // fr-FR: \"dim. 18:02\"\n    return intl.formatDate(date, {\n      weekday: 'short',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  } else if (localizedNow.isSame(date, 'year')) {\n    // e.g.\n    // en-US: \"Jul 20, 6:02 PM\"\n    // en-GB: \"20 Jul, 18:02\"\n    // fr-FR: \"20 juil., 18:02\"\n    return intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  } else {\n    // e.g.\n    // en-US: \"Jul 20, 2020, 6:02 PM\"\n    // en-GB: \"20 Jul 2020, 18:02\"\n    // fr-FR: \"20 juil. 2020, 18:02\"\n    return intl.formatDate(date, {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    });\n  }\n};\n/**\r\n * Formats date to into multiple different ways:\r\n * - date \"Mar 24\"\r\n * - time \"8:07 PM\"\r\n * - dateAndTime: \"Mar 24, 8:07 PM\"\r\n *\r\n * If date is on different year, it will show it.\r\n *\r\n * @param {Date} date to be formatted\r\n * @param {Object} intl Intl object from react-intl\r\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\r\n *\r\n * @returns {Object} \"{ date, time, dateAndTime }\"\r\n */\n\nexport const formatDateIntoPartials = (date, intl, opts = {}) => {\n  // If timeZone parameter is set, use it as formatting option\n  const {\n    timeZone\n  } = opts;\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone); // By default we can use moment() directly but in tests we need to use a specific dates.\n  // Tests inject now() function to intl wich returns predefined date\n\n  const now = intl.now ? moment(intl.now()) : moment(); // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\n\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\n  const yearMaybe = localizedNow.isSame(date, 'year') ? {} : {\n    year: 'numeric'\n  };\n  return {\n    date: intl.formatDate(date, {\n      month: 'short',\n      day: 'numeric',\n      ...yearMaybe,\n      ...timeZoneMaybe\n    }),\n    time: intl.formatDate(date, {\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    }),\n    dateAndTime: intl.formatDate(date, { ...yearMaybe,\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      ...timeZoneMaybe\n    })\n  };\n};\n/**\r\n * Parses given date string in ISO8601 format('YYYY-MM-DD') to date in\r\n * the given time zone.\r\n *\r\n * This is used in search when filtering by time-based availability.\r\n *\r\n * Example:\r\n * ('2020-04-15', 'Etc/UTC') => new Date('2020-04-15T00:00:00.000Z')\r\n * ('2020-04-15', 'Europe/Helsinki') => new Date('2020-04-14T21:00:00.000Z')\r\n *\r\n * @param {String} dateString in 'YYYY-MM-DD' format\r\n * @param {String} [timeZone] time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {Date} date\r\n */\n\nexport const parseDateFromISO8601 = (dateString, timeZone = null) => {\n  return timeZone ? moment.tz(dateString, timeZone).toDate() : moment(dateString, 'YYYY-MM-DD').toDate();\n};\n/**\r\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\r\n * This string is used e.g. in urlParam.\r\n *\r\n * @param {Date} date\r\n * @param {String} [timeZone] time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {String} string in 'YYYY-MM-DD' format\r\n */\n\nexport const stringifyDateToISO8601 = (date, timeZone = null) => {\n  return timeZone ? moment(date).tz(timeZone).format('YYYY-MM-DD') : moment(date).format('YYYY-MM-DD');\n}; //////////\n// Misc //\n//////////\n\n/**\r\n * Format the given date to month id/string: 'YYYY-MM'.\r\n *\r\n * @param {Date} date to be formatted\r\n * @param {String} [timeZone] time zone name (optional parameter).\r\n *\r\n * @returns {String} formatted month string\r\n */\n\nexport const monthIdString = (date, timeZone = null) => {\n  return timeZone ? moment(date).tz(timeZone).format('YYYY-MM') : moment(date).format('YYYY-MM');\n};\n/**\r\n * Formats string ('YYYY-MM-DD') in given time zone to format ('0000-00-00T00:00:00.000Z') and adds one day.\r\n * This is used as end date of the search query.\r\n * One day must be added because end of the availability is exclusive in API.\r\n *\r\n * @param {String} string in 'YYYY-MM-DD'format\r\n * @param {String} timeZone time zone name.\r\n *\r\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\r\n */\n\nexport const getExclusiveEndDate = (dateString, timeZone) => {\n  return moment.tz(dateString, timeZone).add(1, 'days').startOf('day').toDate();\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/dates.js"],"names":["moment","START_DATE","END_DATE","isTimeZoneSupported","Intl","DateTimeFormat","dtf","resolvedOptions","timeZone","isValidTimeZone","format","e","isDate","d","Object","prototype","toString","call","Number","isNaN","getTime","isSameDate","a","b","isAfterDate","dateA","dateB","isAfter","timeOfDayFromLocalToTimeZone","date","tz","toDate","timeOfDayFromTimeZoneToLocal","getStartOf","unit","m","clone","startOf","addTime","offset","add","subtractTime","subtract","daysBetween","startDate","endDate","days","diff","Error","minutesBetween","minutes","diffInTime","useFloat","getTimeZoneMaybe","formatDateWithProximity","intl","todayString","opts","paramsValid","Date","timeZoneMaybe","now","localizedNow","isSame","formattedTime","formatDate","hour","minute","weekday","month","day","year","formatDateIntoPartials","yearMaybe","time","dateAndTime","parseDateFromISO8601","dateString","stringifyDateToISO8601","monthIdString","getExclusiveEndDate"],"mappings":"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","sourcesContent":["import moment from 'moment-timezone/builds/moment-timezone-with-data-10-year-range.min';\r\n\r\n/**\r\n * Input names for the DateRangePicker from react-dates.\r\n */\r\nexport const START_DATE = 'startDate';\r\nexport const END_DATE = 'endDate';\r\n\r\n/**\r\n * Check if the browser's DateTimeFormat API supports time zones.\r\n *\r\n * @returns {Boolean} true if the browser returns current time zone.\r\n */\r\nexport const isTimeZoneSupported = () => {\r\n  if (!Intl || typeof Intl === 'undefined' || typeof Intl.DateTimeFormat === 'undefined') {\r\n    return false;\r\n  }\r\n\r\n  const dtf = new Intl.DateTimeFormat();\r\n  if (typeof dtf === 'undefined' || typeof dtf.resolvedOptions === 'undefined') {\r\n    return false;\r\n  }\r\n  return !!dtf.resolvedOptions().timeZone;\r\n};\r\n\r\n/**\r\n * Check if the given time zone key is valid.\r\n *\r\n * @param {String} timeZone time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {Boolean} true if the browser recognizes the key.\r\n */\r\nexport const isValidTimeZone = timeZone => {\r\n  try {\r\n    new Intl.DateTimeFormat('en-US', { timeZone }).format();\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Check that the given parameter is a Date object.\r\n *\r\n * @param {Date} object that should be a Date.\r\n *\r\n * @returns {boolean} true if given parameter is a Date object.\r\n */\r\nexport const isDate = d =>\r\n  d && Object.prototype.toString.call(d) === '[object Date]' && !Number.isNaN(d.getTime());\r\n\r\n/**\r\n * Check if the given parameters represent the same Date value (timestamps are compared)\r\n *\r\n * @param {Date} first param that should be a Date and it should have same timestamp as second param.\r\n * @param {Date} second param that should be a Date and it should have same timestamp as second param.\r\n *\r\n * @returns {boolean} true if given parameters have the same timestamp.\r\n */\r\nexport const isSameDate = (a, b) => a && isDate(a) && b && isDate(b) && a.getTime() === b.getTime();\r\n\r\n/**\r\n * Compare is dateA is after dateB\r\n *\r\n * @param {Date} dateA date instance\r\n * @param {Date} dateB date instance\r\n *\r\n * @returns {Date} true if dateA is after dateB\r\n */\r\nexport const isAfterDate = (dateA, dateB) => {\r\n  return moment(dateA).isAfter(moment(dateB));\r\n};\r\n\r\n////////////////////////////////////////////////////////////////////\r\n// Manipulate time: time-of-day between different time zones etc. //\r\n////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Returns a new date, which indicates the same time of day in a given time zone\r\n * as given date is in local time zone\r\n *\r\n * @param {Date} date\r\n * @param {String} timeZone\r\n *\r\n * @returns {Date} date in given time zone\r\n */\r\nexport const timeOfDayFromLocalToTimeZone = (date, timeZone) => {\r\n  return moment.tz(moment(date).format('YYYY-MM-DD HH:mm:ss'), timeZone).toDate();\r\n};\r\n\r\n/**\r\n * Returns a new date, which indicates the same time of day in a local time zone\r\n * as given date is in specified time zone\r\n *\r\n * @param {Date} date\r\n * @param {String} timeZone\r\n *\r\n * @returns {Date} date in given time zone\r\n */\r\nexport const timeOfDayFromTimeZoneToLocal = (date, timeZone) => {\r\n  return moment(\r\n    moment(date)\r\n      .tz(timeZone)\r\n      .format('YYYY-MM-DD HH:mm:ss')\r\n  ).toDate();\r\n};\r\n\r\n/**\r\n * Get start of time unit (e.g. start of day)\r\n *\r\n * @param {Date} date date instance to be converted\r\n * @param {String} unit time-unit (e.g. \"day\")\r\n * @param {String} timeZone time zone id\r\n *\r\n * @returns {Date} date object converted to the start of given unit\r\n */\r\nexport const getStartOf = (date, unit, timeZone) => {\r\n  const m = timeZone\r\n    ? moment(date)\r\n        .clone()\r\n        .tz(timeZone)\r\n    : moment(date).clone();\r\n\r\n  return m.startOf(unit).toDate();\r\n};\r\n\r\n/**\r\n * Adds time-units to the date\r\n *\r\n * @param {Date} date date to be manipulated\r\n * @param {int} offset offset of time-units (e.g. \"3\" days)\r\n * @param {String} unit time-unit (e.g. \"days\")\r\n * @param {String} timeZone time zone name\r\n *\r\n * @returns {Date} date with given offset added\r\n */\r\nexport const addTime = (date, offset, unit, timeZone) => {\r\n  const m = timeZone\r\n    ? moment(date)\r\n        .clone()\r\n        .tz(timeZone)\r\n    : moment(date).clone();\r\n  return m.add(offset, unit).toDate();\r\n};\r\n\r\n/**\r\n * Subtract time-units from the date\r\n *\r\n * @param {Date} date date to be manipulated\r\n * @param {int} offset offset of time-units (e.g. \"3\" days)\r\n * @param {String} unit time-unit (e.g. \"days\")\r\n * @param {String} timeZone time zone name\r\n *\r\n * @returns {Date} date with given offset subtracted\r\n */\r\nexport const subtractTime = (date, offset, unit, timeZone) => {\r\n  const m = timeZone\r\n    ? moment(date)\r\n        .clone()\r\n        .tz(timeZone)\r\n    : moment(date).clone();\r\n  return m.subtract(offset, unit).toDate();\r\n};\r\n\r\n///////////////\r\n// Durations //\r\n///////////////\r\n\r\n/**\r\n * Calculate the number of days between the given dates.\r\n * This uses moment#diff and, therefore, it just checks,\r\n * if there are 1000x60x60x24 milliseconds between date objects.\r\n *\r\n * Note: This should not be used for checking if the local date has\r\n *       changed between \"2021-04-07 23:00\" and \"2021-04-08 05:00\".\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period. NOTE: with daily\r\n * bookings, it is expected that this date is the exclusive end date,\r\n * i.e. the last day of the booking is the previous date of this end\r\n * date.\r\n *\r\n * @throws Will throw if the end date is before the start date\r\n * @returns {Number} number of days between the given dates\r\n */\r\nexport const daysBetween = (startDate, endDate) => {\r\n  const days = moment(endDate).diff(startDate, 'days');\r\n  if (days < 0) {\r\n    throw new Error('End date cannot be before start date');\r\n  }\r\n  return days;\r\n};\r\n\r\n/**\r\n * Count the number of minutes between the given Date objects.\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period.\r\n *\r\n * @returns {Number} number of minutes between the given Date objects\r\n */\r\nexport const minutesBetween = (startDate, endDate) => {\r\n  const minutes = moment(endDate).diff(startDate, 'minutes');\r\n  return minutes;\r\n};\r\n\r\n/**\r\n * Calculate the difference between the given dates\r\n *\r\n * @param {Date} startDate start of the time period\r\n * @param {Date} endDate end of the time period.\r\n * @param {String} unit time unit. E.g. 'years'.\r\n * @param {String} useFloat Should return floating point numbers?\r\n *\r\n * @returns {Number} time difference between the given Date objects using given unit\r\n */\r\nexport const diffInTime = (startDate, endDate, unit, useFloat = false) => {\r\n  return moment(startDate).diff(endDate, unit, useFloat);\r\n};\r\n\r\n////////////////////////////\r\n// Parsing and formatting //\r\n////////////////////////////\r\n\r\nconst getTimeZoneMaybe = timeZone => {\r\n  if (timeZone) {\r\n    if (!isTimeZoneSupported()) {\r\n      throw new Error(`Your browser doesn't support time zones.`);\r\n    }\r\n\r\n    if (!isValidTimeZone(timeZone)) {\r\n      throw new Error(`Given time zone key (${timeZone}) is not valid.`);\r\n    }\r\n    return { timeZone };\r\n  }\r\n  return {};\r\n};\r\n\r\n/**\r\n * Format the given date. Printed string depends on how close the date is the current day.\r\n * E.g. \"Today, 9:10 PM\", \"Sun 6:02 PM\", \"Jul 20, 6:02 PM\", \"Jul 20 2020, 6:02 PM\"\r\n *\r\n * @param {Date} date Date to be formatted\r\n * @param {Object} intl Intl object from react-intl\r\n * @param {String} todayString translation for the current day\r\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\r\n *\r\n * @returns {String} formatted date\r\n */\r\nexport const formatDateWithProximity = (date, intl, todayString, opts = {}) => {\r\n  const paramsValid = intl && date instanceof Date && typeof todayString === 'string';\r\n  if (!paramsValid) {\r\n    throw new Error(`Invalid params for formatDate: (${date}, ${intl}, ${todayString})`);\r\n  }\r\n\r\n  // If timeZone parameter is set, use it as formatting option\r\n  const { timeZone } = opts;\r\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone);\r\n\r\n  // By default we can use moment() directly but in tests we need to use a specific dates.\r\n  // Tests inject now() function to intl wich returns predefined date\r\n  const now = intl.now ? moment(intl.now()) : moment();\r\n\r\n  // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\r\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\r\n\r\n  if (localizedNow.isSame(date, 'day')) {\r\n    // e.g. \"Today, 9:10 PM\"\r\n    const formattedTime = intl.formatDate(date, {\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    });\r\n    return `${todayString}, ${formattedTime}`;\r\n  } else if (localizedNow.isSame(date, 'week')) {\r\n    // e.g.\r\n    // en-US: \"Sun 6:02 PM\"\r\n    // en-GB: \"Sun 18:02\"\r\n    // fr-FR: \"dim. 18:02\"\r\n    return intl.formatDate(date, {\r\n      weekday: 'short',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    });\r\n  } else if (localizedNow.isSame(date, 'year')) {\r\n    // e.g.\r\n    // en-US: \"Jul 20, 6:02 PM\"\r\n    // en-GB: \"20 Jul, 18:02\"\r\n    // fr-FR: \"20 juil., 18:02\"\r\n    return intl.formatDate(date, {\r\n      month: 'short',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    });\r\n  } else {\r\n    // e.g.\r\n    // en-US: \"Jul 20, 2020, 6:02 PM\"\r\n    // en-GB: \"20 Jul 2020, 18:02\"\r\n    // fr-FR: \"20 juil. 2020, 18:02\"\r\n    return intl.formatDate(date, {\r\n      year: 'numeric',\r\n      month: 'short',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    });\r\n  }\r\n};\r\n\r\n/**\r\n * Formats date to into multiple different ways:\r\n * - date \"Mar 24\"\r\n * - time \"8:07 PM\"\r\n * - dateAndTime: \"Mar 24, 8:07 PM\"\r\n *\r\n * If date is on different year, it will show it.\r\n *\r\n * @param {Date} date to be formatted\r\n * @param {Object} intl Intl object from react-intl\r\n * @param {Object} [opts] options. Can be used to pass in timeZone. It should represent IANA time zone key.\r\n *\r\n * @returns {Object} \"{ date, time, dateAndTime }\"\r\n */\r\nexport const formatDateIntoPartials = (date, intl, opts = {}) => {\r\n  // If timeZone parameter is set, use it as formatting option\r\n  const { timeZone } = opts;\r\n  const timeZoneMaybe = getTimeZoneMaybe(timeZone);\r\n\r\n  // By default we can use moment() directly but in tests we need to use a specific dates.\r\n  // Tests inject now() function to intl wich returns predefined date\r\n  const now = intl.now ? moment(intl.now()) : moment();\r\n\r\n  // isSame: if the two moments have different time zones, the time zone of the first moment will be used for the comparison.\r\n  const localizedNow = timeZoneMaybe.timeZone ? now.tz(timeZone) : now;\r\n  const yearMaybe = localizedNow.isSame(date, 'year') ? {} : { year: 'numeric' };\r\n\r\n  return {\r\n    date: intl.formatDate(date, {\r\n      month: 'short',\r\n      day: 'numeric',\r\n      ...yearMaybe,\r\n      ...timeZoneMaybe,\r\n    }),\r\n    time: intl.formatDate(date, {\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    }),\r\n    dateAndTime: intl.formatDate(date, {\r\n      ...yearMaybe,\r\n      month: 'short',\r\n      day: 'numeric',\r\n      hour: 'numeric',\r\n      minute: 'numeric',\r\n      ...timeZoneMaybe,\r\n    }),\r\n  };\r\n};\r\n\r\n/**\r\n * Parses given date string in ISO8601 format('YYYY-MM-DD') to date in\r\n * the given time zone.\r\n *\r\n * This is used in search when filtering by time-based availability.\r\n *\r\n * Example:\r\n * ('2020-04-15', 'Etc/UTC') => new Date('2020-04-15T00:00:00.000Z')\r\n * ('2020-04-15', 'Europe/Helsinki') => new Date('2020-04-14T21:00:00.000Z')\r\n *\r\n * @param {String} dateString in 'YYYY-MM-DD' format\r\n * @param {String} [timeZone] time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {Date} date\r\n */\r\nexport const parseDateFromISO8601 = (dateString, timeZone = null) => {\r\n  return timeZone\r\n    ? moment.tz(dateString, timeZone).toDate()\r\n    : moment(dateString, 'YYYY-MM-DD').toDate();\r\n};\r\n\r\n/**\r\n * Converts date to string ISO8601 format ('YYYY-MM-DD').\r\n * This string is used e.g. in urlParam.\r\n *\r\n * @param {Date} date\r\n * @param {String} [timeZone] time zone id, see:\r\n *   https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\r\n *\r\n * @returns {String} string in 'YYYY-MM-DD' format\r\n */\r\nexport const stringifyDateToISO8601 = (date, timeZone = null) => {\r\n  return timeZone\r\n    ? moment(date)\r\n        .tz(timeZone)\r\n        .format('YYYY-MM-DD')\r\n    : moment(date).format('YYYY-MM-DD');\r\n};\r\n\r\n//////////\r\n// Misc //\r\n//////////\r\n\r\n/**\r\n * Format the given date to month id/string: 'YYYY-MM'.\r\n *\r\n * @param {Date} date to be formatted\r\n * @param {String} [timeZone] time zone name (optional parameter).\r\n *\r\n * @returns {String} formatted month string\r\n */\r\nexport const monthIdString = (date, timeZone = null) => {\r\n  return timeZone\r\n    ? moment(date)\r\n        .tz(timeZone)\r\n        .format('YYYY-MM')\r\n    : moment(date).format('YYYY-MM');\r\n};\r\n\r\n/**\r\n * Formats string ('YYYY-MM-DD') in given time zone to format ('0000-00-00T00:00:00.000Z') and adds one day.\r\n * This is used as end date of the search query.\r\n * One day must be added because end of the availability is exclusive in API.\r\n *\r\n * @param {String} string in 'YYYY-MM-DD'format\r\n * @param {String} timeZone time zone name.\r\n *\r\n * @returns {String} string in '0000-00-00T00:00:00.000Z' format\r\n */\r\nexport const getExclusiveEndDate = (dateString, timeZone) => {\r\n  return moment\r\n    .tz(dateString, timeZone)\r\n    .add(1, 'days')\r\n    .startOf('day')\r\n    .toDate();\r\n};\r\n"]},"metadata":{},"sourceType":"module"}