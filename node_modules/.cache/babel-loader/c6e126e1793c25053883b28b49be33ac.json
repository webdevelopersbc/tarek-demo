{"ast":null,"code":"import moment from 'moment';\nimport { isSameDay, isInclusivelyAfterDay, isInclusivelyBeforeDay } from 'react-dates';\nimport { ensureTimeSlot } from '../../util/data';\nimport { START_DATE, END_DATE, timeOfDayFromTimeZoneToLocal } from '../../util/dates';\nimport { LINE_ITEM_DAY, LINE_ITEM_NIGHT, TIME_SLOT_DAY } from '../../util/types';\nimport config from '../../config'; // Checks if time slot (propTypes.timeSlot) start time equals a day (moment)\n\nconst timeSlotEqualsDay = (timeSlot, day) => {\n  if (ensureTimeSlot(timeSlot).attributes.type === TIME_SLOT_DAY) {\n    // Time slots describe available dates by providing a start and\n    // an end date which is the following day. In the single date picker\n    // the start date is used to represent available dates.\n    // In day-based booking process, timeSlots come in server's time zone.\n    const apiTimeZone = 'Etc/UTC';\n    const localStartDate = timeOfDayFromTimeZoneToLocal(timeSlot.attributes.start, apiTimeZone);\n    return isSameDay(day, moment(localStartDate));\n  } else {\n    return false;\n  }\n};\n/**\r\n * Return a boolean indicating if given date can be found in an array\r\n * of tile slots (start dates).\r\n */\n\n\nconst timeSlotsContain = (timeSlots, date) => {\n  return timeSlots.findIndex(slot => timeSlotEqualsDay(slot, date)) > -1;\n};\n/**\r\n * Find first blocked date between two dates.\r\n * If none is found, null is returned.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\n\n\nconst firstBlockedBetween = (timeSlots, startDate, endDate) => {\n  const firstDate = moment(startDate).add(1, 'days');\n\n  if (firstDate.isSame(endDate, 'date')) {\n    return null;\n  }\n\n  return timeSlotsContain(timeSlots, firstDate) ? firstBlockedBetween(timeSlots, firstDate, endDate) : firstDate;\n};\n/**\r\n * Find last blocked date between two dates.\r\n * If none is found, null is returned.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\n\n\nconst lastBlockedBetween = (timeSlots, startDate, endDate) => {\n  const previousDate = moment(endDate).subtract(1, 'days');\n\n  if (previousDate.isSame(startDate, 'date')) {\n    return null;\n  }\n\n  return timeSlotsContain(timeSlots, previousDate) ? lastBlockedBetween(timeSlots, startDate, previousDate) : previousDate;\n};\n/**\r\n * Check if a blocked date can be found between two dates.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\n\n\nexport const isBlockedBetween = (timeSlots, startDate, endDate) => !!firstBlockedBetween(timeSlots, startDate, endDate);\nexport const isStartDateSelected = (timeSlots, startDate, endDate, focusedInput) => timeSlots && startDate && (!endDate || focusedInput === END_DATE) && focusedInput !== START_DATE;\nexport const isSelectingEndDateNightly = (timeSlots, startDate, endDate, focusedInput, unitType) => timeSlots && !startDate && !endDate && focusedInput === END_DATE && unitType === LINE_ITEM_NIGHT;\nexport const apiEndDateToPickerDate = (unitType, endDate) => {\n  const isValid = endDate instanceof Date;\n  const isDaily = unitType === LINE_ITEM_DAY;\n\n  if (!isValid) {\n    return null;\n  } else if (isDaily) {\n    // API end dates are exlusive, so we need to shift them with daily\n    // booking.\n    return moment(endDate).subtract(1, 'days');\n  } else {\n    return moment(endDate);\n  }\n};\nexport const pickerEndDateToApiDate = (unitType, endDate) => {\n  const isValid = endDate instanceof moment;\n  const isDaily = unitType === LINE_ITEM_DAY;\n\n  if (!isValid) {\n    return null;\n  } else if (isDaily) {\n    // API end dates are exlusive, so we need to shift them with daily\n    // booking.\n    return endDate.add(1, 'days').toDate();\n  } else {\n    return endDate.toDate();\n  }\n};\n/**\r\n * Returns an isDayBlocked function that can be passed to\r\n * a react-dates DateRangePicker component.\r\n */\n\nexport const isDayBlockedFn = (timeSlots, startDate, endDate, focusedInput, unitType) => {\n  const endOfRange = config.dayCountAvailableForBooking - 1;\n  const lastBookableDate = moment().add(endOfRange, 'days'); // start date selected, end date missing\n\n  const startDateSelected = isStartDateSelected(timeSlots, startDate, endDate, focusedInput); // find the next booking after a start date\n\n  const nextBookingStarts = startDateSelected ? firstBlockedBetween(timeSlots, startDate, moment(lastBookableDate).add(1, 'days')) : null; // end date is focused but no dates are selected\n\n  const selectingEndDate = isSelectingEndDateNightly(timeSlots, startDate, endDate, focusedInput, unitType);\n\n  if (selectingEndDate) {\n    // if end date is being selected first, block the day after a booked date\n    // (as a booking can end on the day the following booking starts)\n    return day => !timeSlots.find(timeSlot => timeSlotEqualsDay(timeSlot, moment(day).subtract(1, 'days')));\n  } else if (nextBookingStarts || !timeSlots) {\n    // a next booking is found or time slots are not provided\n    // -> booking range handles blocking dates\n    return () => false;\n  } else {\n    // otherwise return standard timeslots check\n    return day => !timeSlots.find(timeSlot => timeSlotEqualsDay(timeSlot, day));\n  }\n};\n/**\r\n * Returns an isOutsideRange function that can be passed to\r\n * a react-dates DateRangePicker component.\r\n */\n\nexport const isOutsideRangeFn = (timeSlots, startDate, endDate, focusedInput, unitType) => {\n  const endOfRange = config.dayCountAvailableForBooking - 1;\n  const lastBookableDate = moment().add(endOfRange, 'days'); // start date selected, end date missing\n\n  const startDateSelected = isStartDateSelected(timeSlots, startDate, endDate, focusedInput);\n  const nextBookingStarts = startDateSelected ? firstBlockedBetween(timeSlots, startDate, moment(lastBookableDate).add(1, 'days')) : null;\n\n  if (nextBookingStarts) {\n    // end the range so that the booking can end at latest on\n    // nightly booking: the day the next booking starts\n    // daily booking: the day before the next booking starts\n    return day => {\n      const lastDayToEndBooking = apiEndDateToPickerDate(unitType, nextBookingStarts.toDate());\n      return !isInclusivelyAfterDay(day, startDate) || !isInclusivelyBeforeDay(day, lastDayToEndBooking);\n    };\n  } // end date selected, start date missing\n  // -> limit the earliest start date for the booking so that it\n  // needs to be after the previous booked date\n\n\n  const endDateSelected = timeSlots && endDate && !startDate && focusedInput !== END_DATE;\n  const previousBookedDate = endDateSelected ? lastBlockedBetween(timeSlots, moment(), endDate) : null;\n\n  if (previousBookedDate) {\n    return day => {\n      const firstDayToStartBooking = moment(previousBookedDate).add(1, 'days');\n      return !isInclusivelyAfterDay(day, firstDayToStartBooking) || !isInclusivelyBeforeDay(day, lastBookableDate);\n    };\n  } // standard isOutsideRange function\n\n\n  return day => {\n    return !isInclusivelyAfterDay(day, moment()) || !isInclusivelyBeforeDay(day, moment().add(endOfRange, 'days'));\n  };\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/components/FieldDateRangeInput/DateRangeInput.helpers.js"],"names":["moment","isSameDay","isInclusivelyAfterDay","isInclusivelyBeforeDay","ensureTimeSlot","START_DATE","END_DATE","timeOfDayFromTimeZoneToLocal","LINE_ITEM_DAY","LINE_ITEM_NIGHT","TIME_SLOT_DAY","config","timeSlotEqualsDay","timeSlot","day","attributes","type","apiTimeZone","localStartDate","start","timeSlotsContain","timeSlots","date","findIndex","slot","firstBlockedBetween","startDate","endDate","firstDate","add","isSame","lastBlockedBetween","previousDate","subtract","isBlockedBetween","isStartDateSelected","focusedInput","isSelectingEndDateNightly","unitType","apiEndDateToPickerDate","isValid","Date","isDaily","pickerEndDateToApiDate","toDate","isDayBlockedFn","endOfRange","dayCountAvailableForBooking","lastBookableDate","startDateSelected","nextBookingStarts","selectingEndDate","find","isOutsideRangeFn","lastDayToEndBooking","endDateSelected","previousBookedDate","firstDayToStartBooking"],"mappings":"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","sourcesContent":["import moment from 'moment';\r\nimport { isSameDay, isInclusivelyAfterDay, isInclusivelyBeforeDay } from 'react-dates';\r\n\r\nimport { ensureTimeSlot } from '../../util/data';\r\nimport { START_DATE, END_DATE, timeOfDayFromTimeZoneToLocal } from '../../util/dates';\r\nimport { LINE_ITEM_DAY, LINE_ITEM_NIGHT, TIME_SLOT_DAY } from '../../util/types';\r\nimport config from '../../config';\r\n\r\n// Checks if time slot (propTypes.timeSlot) start time equals a day (moment)\r\nconst timeSlotEqualsDay = (timeSlot, day) => {\r\n  if (ensureTimeSlot(timeSlot).attributes.type === TIME_SLOT_DAY) {\r\n    // Time slots describe available dates by providing a start and\r\n    // an end date which is the following day. In the single date picker\r\n    // the start date is used to represent available dates.\r\n\r\n    // In day-based booking process, timeSlots come in server's time zone.\r\n    const apiTimeZone = 'Etc/UTC';\r\n    const localStartDate = timeOfDayFromTimeZoneToLocal(timeSlot.attributes.start, apiTimeZone);\r\n\r\n    return isSameDay(day, moment(localStartDate));\r\n  } else {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Return a boolean indicating if given date can be found in an array\r\n * of tile slots (start dates).\r\n */\r\nconst timeSlotsContain = (timeSlots, date) => {\r\n  return timeSlots.findIndex(slot => timeSlotEqualsDay(slot, date)) > -1;\r\n};\r\n\r\n/**\r\n * Find first blocked date between two dates.\r\n * If none is found, null is returned.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\r\nconst firstBlockedBetween = (timeSlots, startDate, endDate) => {\r\n  const firstDate = moment(startDate).add(1, 'days');\r\n  if (firstDate.isSame(endDate, 'date')) {\r\n    return null;\r\n  }\r\n\r\n  return timeSlotsContain(timeSlots, firstDate)\r\n    ? firstBlockedBetween(timeSlots, firstDate, endDate)\r\n    : firstDate;\r\n};\r\n\r\n/**\r\n * Find last blocked date between two dates.\r\n * If none is found, null is returned.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\r\nconst lastBlockedBetween = (timeSlots, startDate, endDate) => {\r\n  const previousDate = moment(endDate).subtract(1, 'days');\r\n  if (previousDate.isSame(startDate, 'date')) {\r\n    return null;\r\n  }\r\n\r\n  return timeSlotsContain(timeSlots, previousDate)\r\n    ? lastBlockedBetween(timeSlots, startDate, previousDate)\r\n    : previousDate;\r\n};\r\n\r\n/**\r\n * Check if a blocked date can be found between two dates.\r\n *\r\n * @param {Array} timeSlots propTypes.timeSlot objects\r\n * @param {Moment} startDate start date, exclusive\r\n * @param {Moment} endDate end date, exclusive\r\n */\r\nexport const isBlockedBetween = (timeSlots, startDate, endDate) =>\r\n  !!firstBlockedBetween(timeSlots, startDate, endDate);\r\n\r\nexport const isStartDateSelected = (timeSlots, startDate, endDate, focusedInput) =>\r\n  timeSlots && startDate && (!endDate || focusedInput === END_DATE) && focusedInput !== START_DATE;\r\n\r\nexport const isSelectingEndDateNightly = (timeSlots, startDate, endDate, focusedInput, unitType) =>\r\n  timeSlots && !startDate && !endDate && focusedInput === END_DATE && unitType === LINE_ITEM_NIGHT;\r\n\r\nexport const apiEndDateToPickerDate = (unitType, endDate) => {\r\n  const isValid = endDate instanceof Date;\r\n  const isDaily = unitType === LINE_ITEM_DAY;\r\n\r\n  if (!isValid) {\r\n    return null;\r\n  } else if (isDaily) {\r\n    // API end dates are exlusive, so we need to shift them with daily\r\n    // booking.\r\n    return moment(endDate).subtract(1, 'days');\r\n  } else {\r\n    return moment(endDate);\r\n  }\r\n};\r\n\r\nexport const pickerEndDateToApiDate = (unitType, endDate) => {\r\n  const isValid = endDate instanceof moment;\r\n  const isDaily = unitType === LINE_ITEM_DAY;\r\n\r\n  if (!isValid) {\r\n    return null;\r\n  } else if (isDaily) {\r\n    // API end dates are exlusive, so we need to shift them with daily\r\n    // booking.\r\n    return endDate.add(1, 'days').toDate();\r\n  } else {\r\n    return endDate.toDate();\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an isDayBlocked function that can be passed to\r\n * a react-dates DateRangePicker component.\r\n */\r\nexport const isDayBlockedFn = (timeSlots, startDate, endDate, focusedInput, unitType) => {\r\n  const endOfRange = config.dayCountAvailableForBooking - 1;\r\n  const lastBookableDate = moment().add(endOfRange, 'days');\r\n\r\n  // start date selected, end date missing\r\n  const startDateSelected = isStartDateSelected(timeSlots, startDate, endDate, focusedInput);\r\n\r\n  // find the next booking after a start date\r\n  const nextBookingStarts = startDateSelected\r\n    ? firstBlockedBetween(timeSlots, startDate, moment(lastBookableDate).add(1, 'days'))\r\n    : null;\r\n\r\n  // end date is focused but no dates are selected\r\n  const selectingEndDate = isSelectingEndDateNightly(\r\n    timeSlots,\r\n    startDate,\r\n    endDate,\r\n    focusedInput,\r\n    unitType\r\n  );\r\n\r\n  if (selectingEndDate) {\r\n    // if end date is being selected first, block the day after a booked date\r\n    // (as a booking can end on the day the following booking starts)\r\n    return day =>\r\n      !timeSlots.find(timeSlot => timeSlotEqualsDay(timeSlot, moment(day).subtract(1, 'days')));\r\n  } else if (nextBookingStarts || !timeSlots) {\r\n    // a next booking is found or time slots are not provided\r\n    // -> booking range handles blocking dates\r\n    return () => false;\r\n  } else {\r\n    // otherwise return standard timeslots check\r\n    return day => !timeSlots.find(timeSlot => timeSlotEqualsDay(timeSlot, day));\r\n  }\r\n};\r\n\r\n/**\r\n * Returns an isOutsideRange function that can be passed to\r\n * a react-dates DateRangePicker component.\r\n */\r\nexport const isOutsideRangeFn = (timeSlots, startDate, endDate, focusedInput, unitType) => {\r\n  const endOfRange = config.dayCountAvailableForBooking - 1;\r\n  const lastBookableDate = moment().add(endOfRange, 'days');\r\n\r\n  // start date selected, end date missing\r\n  const startDateSelected = isStartDateSelected(timeSlots, startDate, endDate, focusedInput);\r\n  const nextBookingStarts = startDateSelected\r\n    ? firstBlockedBetween(timeSlots, startDate, moment(lastBookableDate).add(1, 'days'))\r\n    : null;\r\n\r\n  if (nextBookingStarts) {\r\n    // end the range so that the booking can end at latest on\r\n    // nightly booking: the day the next booking starts\r\n    // daily booking: the day before the next booking starts\r\n    return day => {\r\n      const lastDayToEndBooking = apiEndDateToPickerDate(unitType, nextBookingStarts.toDate());\r\n\r\n      return (\r\n        !isInclusivelyAfterDay(day, startDate) || !isInclusivelyBeforeDay(day, lastDayToEndBooking)\r\n      );\r\n    };\r\n  }\r\n\r\n  // end date selected, start date missing\r\n  // -> limit the earliest start date for the booking so that it\r\n  // needs to be after the previous booked date\r\n  const endDateSelected = timeSlots && endDate && !startDate && focusedInput !== END_DATE;\r\n  const previousBookedDate = endDateSelected\r\n    ? lastBlockedBetween(timeSlots, moment(), endDate)\r\n    : null;\r\n\r\n  if (previousBookedDate) {\r\n    return day => {\r\n      const firstDayToStartBooking = moment(previousBookedDate).add(1, 'days');\r\n      return (\r\n        !isInclusivelyAfterDay(day, firstDayToStartBooking) ||\r\n        !isInclusivelyBeforeDay(day, lastBookableDate)\r\n      );\r\n    };\r\n  }\r\n\r\n  // standard isOutsideRange function\r\n  return day => {\r\n    return (\r\n      !isInclusivelyAfterDay(day, moment()) ||\r\n      !isInclusivelyBeforeDay(day, moment().add(endOfRange, 'days'))\r\n    );\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}