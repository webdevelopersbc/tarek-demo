{"ast":null,"code":"import queryString from 'query-string';\nimport { types as sdkTypes } from './sdkLoader';\nconst {\n  LatLng,\n  LatLngBounds\n} = sdkTypes;\nexport const LISTING_PAGE_PENDING_APPROVAL_VARIANT = 'pending-approval';\nexport const LISTING_PAGE_DRAFT_VARIANT = 'draft';\nexport const LISTING_PAGE_PARAM_TYPE_NEW = 'new';\nexport const LISTING_PAGE_PARAM_TYPE_DRAFT = 'draft';\nexport const LISTING_PAGE_PARAM_TYPE_EDIT = 'edit';\nexport const LISTING_PAGE_PARAM_TYPES = [LISTING_PAGE_PARAM_TYPE_NEW, LISTING_PAGE_PARAM_TYPE_DRAFT, LISTING_PAGE_PARAM_TYPE_EDIT]; // Create slug from random texts\n// From Gist thread: https://gist.github.com/mathewbyrne/1280286\n\nexport const createSlug = str => {\n  let text = str.toString().toLowerCase().trim();\n  const sets = [{\n    to: 'a',\n    from: 'ÀÁÂÃÄÅÆĀĂĄẠẢẤẦẨẪẬẮẰẲẴẶ'\n  }, {\n    to: 'c',\n    from: 'ÇĆĈČ'\n  }, {\n    to: 'd',\n    from: 'ÐĎĐÞ'\n  }, {\n    to: 'e',\n    from: 'ÈÉÊËĒĔĖĘĚẸẺẼẾỀỂỄỆ'\n  }, {\n    to: 'g',\n    from: 'ĜĞĢǴ'\n  }, {\n    to: 'h',\n    from: 'ĤḦ'\n  }, {\n    to: 'i',\n    from: 'ÌÍÎÏĨĪĮİỈỊ'\n  }, {\n    to: 'j',\n    from: 'Ĵ'\n  }, {\n    to: 'ij',\n    from: 'Ĳ'\n  }, {\n    to: 'k',\n    from: 'Ķ'\n  }, {\n    to: 'l',\n    from: 'ĹĻĽŁ'\n  }, {\n    to: 'm',\n    from: 'Ḿ'\n  }, {\n    to: 'n',\n    from: 'ÑŃŅŇ'\n  }, {\n    to: 'o',\n    from: 'ÒÓÔÕÖØŌŎŐỌỎỐỒỔỖỘỚỜỞỠỢǪǬƠ'\n  }, {\n    to: 'oe',\n    from: 'Œ'\n  }, {\n    to: 'p',\n    from: 'ṕ'\n  }, {\n    to: 'r',\n    from: 'ŔŖŘ'\n  }, {\n    to: 's',\n    from: 'ßŚŜŞŠ'\n  }, {\n    to: 't',\n    from: 'ŢŤ'\n  }, {\n    to: 'u',\n    from: 'ÙÚÛÜŨŪŬŮŰŲỤỦỨỪỬỮỰƯ'\n  }, {\n    to: 'w',\n    from: 'ẂŴẀẄ'\n  }, {\n    to: 'x',\n    from: 'ẍ'\n  }, {\n    to: 'y',\n    from: 'ÝŶŸỲỴỶỸ'\n  }, {\n    to: 'z',\n    from: 'ŹŻŽ'\n  }, {\n    to: '-',\n    from: \"·/_,:;'\"\n  }];\n  sets.forEach(set => {\n    text = text.replace(new RegExp(`[${set.from}]`, 'gi'), set.to);\n  });\n  const slug = encodeURIComponent(text.replace(/\\s+/g, '-') // Replace spaces with -\n  .replace(/[^\\w-]+/g, '') // Remove all non-word chars\n  .replace(/--+/g, '-') // Replace multiple - with single -\n  .replace(/^-+/, '') // Trim - from start of text\n  .replace(/-+$/, '') // Trim - from end of text\n  );\n  return slug.length > 0 ? slug : 'no-slug';\n};\n/**\r\n * Parse float from a string\r\n *\r\n * @param {String} str - string to parse\r\n *\r\n * @return {Number|null} number parsed from the string, null if not a number\r\n */\n\nexport const parseFloatNum = str => {\n  const trimmed = str && typeof str.trim === 'function' ? str.trim() : null;\n\n  if (!trimmed) {\n    return null;\n  }\n\n  const num = parseFloat(trimmed);\n  const isNumber = !isNaN(num);\n  const isFullyParsedNum = isNumber && num.toString() === trimmed;\n  return isFullyParsedNum ? num : null;\n};\n/**\r\n * Encode a location to use in a URL\r\n *\r\n * @param {LatLng} location - location instance to encode\r\n *\r\n * @return {String} location coordinates separated by a comma\r\n */\n\nexport const encodeLatLng = location => `${location.lat},${location.lng}`;\n/**\r\n * Decode a location from a string\r\n *\r\n * @param {String} str - string encoded with `encodeLatLng`\r\n *\r\n * @return {LatLng|null} location instance, null if could not parse\r\n */\n\nexport const decodeLatLng = str => {\n  const parts = str.split(',');\n\n  if (parts.length !== 2) {\n    return null;\n  }\n\n  const lat = parseFloatNum(parts[0]);\n  const lng = parseFloatNum(parts[1]);\n\n  if (lat === null || lng === null) {\n    return null;\n  }\n\n  return new LatLng(lat, lng);\n};\n/**\r\n * Encode a location bounds to use in a URL\r\n *\r\n * @param {LatLngBounds} bounds - bounds instance to encode\r\n *\r\n * @return {String} bounds coordinates separated by a comma\r\n */\n\nexport const encodeLatLngBounds = bounds => `${encodeLatLng(bounds.ne)},${encodeLatLng(bounds.sw)}`;\n/**\r\n * Decode a location bounds from a string\r\n *\r\n * @param {String} str - string encoded with `encodeLatLngBounds`\r\n *\r\n * @return {LatLngBounds|null} location bounds instance, null if could not parse\r\n */\n\nexport const decodeLatLngBounds = str => {\n  const parts = str.split(',');\n\n  if (parts.length !== 4) {\n    return null;\n  }\n\n  const ne = decodeLatLng(`${parts[0]},${parts[1]}`);\n  const sw = decodeLatLng(`${parts[2]},${parts[3]}`);\n\n  if (ne === null || sw === null) {\n    return null;\n  }\n\n  return new LatLngBounds(ne, sw);\n}; // Serialise SDK types in given object values into strings\n\nconst serialiseSdkTypes = obj => Object.keys(obj).reduce((result, key) => {\n  const val = obj[key];\n  /* eslint-disable no-param-reassign */\n\n  if (val instanceof LatLngBounds) {\n    result[key] = encodeLatLngBounds(val);\n  } else if (val instanceof LatLng) {\n    result[key] = encodeLatLng(val);\n  } else {\n    result[key] = val;\n  }\n  /* eslint-enable no-param-reassign */\n\n\n  return result;\n}, {});\n/**\r\n * Serialise given object into a string that can be used in a\r\n * URL. Encode SDK types into a format that can be parsed with `parse`\r\n * defined below.\r\n *\r\n * @param {Object} params - object with strings/numbers/booleans or\r\n * SDK types as values\r\n *\r\n * @return {String} query string with sorted keys and serialised\r\n * values, `undefined` and `null` values are removed\r\n */\n\n\nexport const stringify = params => {\n  const serialised = serialiseSdkTypes(params);\n  const cleaned = Object.keys(serialised).reduce((result, key) => {\n    const val = serialised[key];\n    /* eslint-disable no-param-reassign */\n\n    if (val !== null) {\n      result[key] = val;\n    }\n    /* eslint-enable no-param-reassign */\n\n\n    return result;\n  }, {});\n  return queryString.stringify(cleaned);\n};\n/**\r\n * Parse a URL search query. Converts numeric values into numbers,\r\n * 'true' and 'false' as booleans, and serialised LatLng and\r\n * LatLngBounds into respective instances based on given options.\r\n *\r\n * @param {String} search - query string to parse, optionally with a\r\n * leading '?' or '#' character\r\n *\r\n * @param {Object} options - Options for parsing:\r\n *\r\n * - latlng {Array<String} keys to parse as LatLng instances, null if\r\n *   not able to parse\r\n * - latlngBounds {Array<String} keys to parse as LatLngBounds\r\n *   instances, null if not able to parse\r\n *\r\n * @return {Object} key/value pairs parsed from the given String\r\n */\n\nexport const parse = (search, options = {}) => {\n  const {\n    latlng = [],\n    latlngBounds = []\n  } = options;\n  const params = queryString.parse(search);\n  return Object.keys(params).reduce((result, key) => {\n    const val = params[key];\n    /* eslint-disable no-param-reassign */\n\n    if (latlng.includes(key)) {\n      result[key] = decodeLatLng(val);\n    } else if (latlngBounds.includes(key)) {\n      result[key] = decodeLatLngBounds(val);\n    } else if (val === 'true') {\n      result[key] = true;\n    } else if (val === 'false') {\n      result[key] = false;\n    } else {\n      const num = parseFloatNum(val);\n      result[key] = num === null ? val : num;\n    }\n    /* eslint-enable no-param-reassign */\n\n\n    return result;\n  }, {});\n};\n/**\r\n * Create Twitter page url from twitterHandle\r\n *\r\n * @param {String} twitterHandle - handle is used for generating Twitter page URL\r\n *\r\n * @return {String} twitterPageURL\r\n */\n\nexport const twitterPageURL = twitterHandle => {\n  if (twitterHandle && twitterHandle.charAt(0) === '@') {\n    return `https://twitter.com/${twitterHandle.substring(1)}`;\n  } else if (twitterHandle) {\n    return `https://twitter.com/${twitterHandle}`;\n  }\n\n  return null;\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/urlHelpers.js"],"names":["queryString","types","sdkTypes","LatLng","LatLngBounds","LISTING_PAGE_PENDING_APPROVAL_VARIANT","LISTING_PAGE_DRAFT_VARIANT","LISTING_PAGE_PARAM_TYPE_NEW","LISTING_PAGE_PARAM_TYPE_DRAFT","LISTING_PAGE_PARAM_TYPE_EDIT","LISTING_PAGE_PARAM_TYPES","createSlug","str","text","toString","toLowerCase","trim","sets","to","from","forEach","set","replace","RegExp","slug","encodeURIComponent","length","parseFloatNum","trimmed","num","parseFloat","isNumber","isNaN","isFullyParsedNum","encodeLatLng","location","lat","lng","decodeLatLng","parts","split","encodeLatLngBounds","bounds","ne","sw","decodeLatLngBounds","serialiseSdkTypes","obj","Object","keys","reduce","result","key","val","stringify","params","serialised","cleaned","parse","search","options","latlng","latlngBounds","includes","twitterPageURL","twitterHandle","charAt","substring"],"mappings":"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","sourcesContent":["import queryString from 'query-string';\r\nimport { types as sdkTypes } from './sdkLoader';\r\n\r\nconst { LatLng, LatLngBounds } = sdkTypes;\r\n\r\nexport const LISTING_PAGE_PENDING_APPROVAL_VARIANT = 'pending-approval';\r\nexport const LISTING_PAGE_DRAFT_VARIANT = 'draft';\r\n\r\nexport const LISTING_PAGE_PARAM_TYPE_NEW = 'new';\r\nexport const LISTING_PAGE_PARAM_TYPE_DRAFT = 'draft';\r\nexport const LISTING_PAGE_PARAM_TYPE_EDIT = 'edit';\r\nexport const LISTING_PAGE_PARAM_TYPES = [\r\n  LISTING_PAGE_PARAM_TYPE_NEW,\r\n  LISTING_PAGE_PARAM_TYPE_DRAFT,\r\n  LISTING_PAGE_PARAM_TYPE_EDIT,\r\n];\r\n\r\n// Create slug from random texts\r\n// From Gist thread: https://gist.github.com/mathewbyrne/1280286\r\nexport const createSlug = str => {\r\n  let text = str\r\n    .toString()\r\n    .toLowerCase()\r\n    .trim();\r\n\r\n  const sets = [\r\n    { to: 'a', from: 'ÀÁÂÃÄÅÆĀĂĄẠẢẤẦẨẪẬẮẰẲẴẶ' },\r\n    { to: 'c', from: 'ÇĆĈČ' },\r\n    { to: 'd', from: 'ÐĎĐÞ' },\r\n    { to: 'e', from: 'ÈÉÊËĒĔĖĘĚẸẺẼẾỀỂỄỆ' },\r\n    { to: 'g', from: 'ĜĞĢǴ' },\r\n    { to: 'h', from: 'ĤḦ' },\r\n    { to: 'i', from: 'ÌÍÎÏĨĪĮİỈỊ' },\r\n    { to: 'j', from: 'Ĵ' },\r\n    { to: 'ij', from: 'Ĳ' },\r\n    { to: 'k', from: 'Ķ' },\r\n    { to: 'l', from: 'ĹĻĽŁ' },\r\n    { to: 'm', from: 'Ḿ' },\r\n    { to: 'n', from: 'ÑŃŅŇ' },\r\n    { to: 'o', from: 'ÒÓÔÕÖØŌŎŐỌỎỐỒỔỖỘỚỜỞỠỢǪǬƠ' },\r\n    { to: 'oe', from: 'Œ' },\r\n    { to: 'p', from: 'ṕ' },\r\n    { to: 'r', from: 'ŔŖŘ' },\r\n    { to: 's', from: 'ßŚŜŞŠ' },\r\n    { to: 't', from: 'ŢŤ' },\r\n    { to: 'u', from: 'ÙÚÛÜŨŪŬŮŰŲỤỦỨỪỬỮỰƯ' },\r\n    { to: 'w', from: 'ẂŴẀẄ' },\r\n    { to: 'x', from: 'ẍ' },\r\n    { to: 'y', from: 'ÝŶŸỲỴỶỸ' },\r\n    { to: 'z', from: 'ŹŻŽ' },\r\n    { to: '-', from: \"·/_,:;'\" },\r\n  ];\r\n\r\n  sets.forEach(set => {\r\n    text = text.replace(new RegExp(`[${set.from}]`, 'gi'), set.to);\r\n  });\r\n\r\n  const slug = encodeURIComponent(\r\n    text\r\n      .replace(/\\s+/g, '-') // Replace spaces with -\r\n      .replace(/[^\\w-]+/g, '') // Remove all non-word chars\r\n      .replace(/--+/g, '-') // Replace multiple - with single -\r\n      .replace(/^-+/, '') // Trim - from start of text\r\n      .replace(/-+$/, '') // Trim - from end of text\r\n  );\r\n\r\n  return slug.length > 0 ? slug : 'no-slug';\r\n};\r\n\r\n/**\r\n * Parse float from a string\r\n *\r\n * @param {String} str - string to parse\r\n *\r\n * @return {Number|null} number parsed from the string, null if not a number\r\n */\r\nexport const parseFloatNum = str => {\r\n  const trimmed = str && typeof str.trim === 'function' ? str.trim() : null;\r\n  if (!trimmed) {\r\n    return null;\r\n  }\r\n  const num = parseFloat(trimmed);\r\n  const isNumber = !isNaN(num);\r\n  const isFullyParsedNum = isNumber && num.toString() === trimmed;\r\n  return isFullyParsedNum ? num : null;\r\n};\r\n\r\n/**\r\n * Encode a location to use in a URL\r\n *\r\n * @param {LatLng} location - location instance to encode\r\n *\r\n * @return {String} location coordinates separated by a comma\r\n */\r\nexport const encodeLatLng = location => `${location.lat},${location.lng}`;\r\n\r\n/**\r\n * Decode a location from a string\r\n *\r\n * @param {String} str - string encoded with `encodeLatLng`\r\n *\r\n * @return {LatLng|null} location instance, null if could not parse\r\n */\r\nexport const decodeLatLng = str => {\r\n  const parts = str.split(',');\r\n  if (parts.length !== 2) {\r\n    return null;\r\n  }\r\n  const lat = parseFloatNum(parts[0]);\r\n  const lng = parseFloatNum(parts[1]);\r\n  if (lat === null || lng === null) {\r\n    return null;\r\n  }\r\n  return new LatLng(lat, lng);\r\n};\r\n\r\n/**\r\n * Encode a location bounds to use in a URL\r\n *\r\n * @param {LatLngBounds} bounds - bounds instance to encode\r\n *\r\n * @return {String} bounds coordinates separated by a comma\r\n */\r\nexport const encodeLatLngBounds = bounds => `${encodeLatLng(bounds.ne)},${encodeLatLng(bounds.sw)}`;\r\n\r\n/**\r\n * Decode a location bounds from a string\r\n *\r\n * @param {String} str - string encoded with `encodeLatLngBounds`\r\n *\r\n * @return {LatLngBounds|null} location bounds instance, null if could not parse\r\n */\r\nexport const decodeLatLngBounds = str => {\r\n  const parts = str.split(',');\r\n  if (parts.length !== 4) {\r\n    return null;\r\n  }\r\n  const ne = decodeLatLng(`${parts[0]},${parts[1]}`);\r\n  const sw = decodeLatLng(`${parts[2]},${parts[3]}`);\r\n  if (ne === null || sw === null) {\r\n    return null;\r\n  }\r\n  return new LatLngBounds(ne, sw);\r\n};\r\n\r\n// Serialise SDK types in given object values into strings\r\nconst serialiseSdkTypes = obj =>\r\n  Object.keys(obj).reduce((result, key) => {\r\n    const val = obj[key];\r\n    /* eslint-disable no-param-reassign */\r\n    if (val instanceof LatLngBounds) {\r\n      result[key] = encodeLatLngBounds(val);\r\n    } else if (val instanceof LatLng) {\r\n      result[key] = encodeLatLng(val);\r\n    } else {\r\n      result[key] = val;\r\n    }\r\n    /* eslint-enable no-param-reassign */\r\n    return result;\r\n  }, {});\r\n\r\n/**\r\n * Serialise given object into a string that can be used in a\r\n * URL. Encode SDK types into a format that can be parsed with `parse`\r\n * defined below.\r\n *\r\n * @param {Object} params - object with strings/numbers/booleans or\r\n * SDK types as values\r\n *\r\n * @return {String} query string with sorted keys and serialised\r\n * values, `undefined` and `null` values are removed\r\n */\r\nexport const stringify = params => {\r\n  const serialised = serialiseSdkTypes(params);\r\n  const cleaned = Object.keys(serialised).reduce((result, key) => {\r\n    const val = serialised[key];\r\n    /* eslint-disable no-param-reassign */\r\n    if (val !== null) {\r\n      result[key] = val;\r\n    }\r\n    /* eslint-enable no-param-reassign */\r\n    return result;\r\n  }, {});\r\n  return queryString.stringify(cleaned);\r\n};\r\n\r\n/**\r\n * Parse a URL search query. Converts numeric values into numbers,\r\n * 'true' and 'false' as booleans, and serialised LatLng and\r\n * LatLngBounds into respective instances based on given options.\r\n *\r\n * @param {String} search - query string to parse, optionally with a\r\n * leading '?' or '#' character\r\n *\r\n * @param {Object} options - Options for parsing:\r\n *\r\n * - latlng {Array<String} keys to parse as LatLng instances, null if\r\n *   not able to parse\r\n * - latlngBounds {Array<String} keys to parse as LatLngBounds\r\n *   instances, null if not able to parse\r\n *\r\n * @return {Object} key/value pairs parsed from the given String\r\n */\r\nexport const parse = (search, options = {}) => {\r\n  const { latlng = [], latlngBounds = [] } = options;\r\n  const params = queryString.parse(search);\r\n  return Object.keys(params).reduce((result, key) => {\r\n    const val = params[key];\r\n    /* eslint-disable no-param-reassign */\r\n    if (latlng.includes(key)) {\r\n      result[key] = decodeLatLng(val);\r\n    } else if (latlngBounds.includes(key)) {\r\n      result[key] = decodeLatLngBounds(val);\r\n    } else if (val === 'true') {\r\n      result[key] = true;\r\n    } else if (val === 'false') {\r\n      result[key] = false;\r\n    } else {\r\n      const num = parseFloatNum(val);\r\n      result[key] = num === null ? val : num;\r\n    }\r\n    /* eslint-enable no-param-reassign */\r\n    return result;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Create Twitter page url from twitterHandle\r\n *\r\n * @param {String} twitterHandle - handle is used for generating Twitter page URL\r\n *\r\n * @return {String} twitterPageURL\r\n */\r\nexport const twitterPageURL = twitterHandle => {\r\n  if (twitterHandle && twitterHandle.charAt(0) === '@') {\r\n    return `https://twitter.com/${twitterHandle.substring(1)}`;\r\n  } else if (twitterHandle) {\r\n    return `https://twitter.com/${twitterHandle}`;\r\n  }\r\n  return null;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}