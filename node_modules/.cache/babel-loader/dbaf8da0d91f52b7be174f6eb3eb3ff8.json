{"ast":null,"code":"import find from 'lodash/find';\nimport { matchPath } from 'react-router-dom';\nimport { compile } from 'path-to-regexp';\nimport { stringify } from './urlHelpers';\n\nconst findRouteByName = (nameToFind, routes) => find(routes, route => route.name === nameToFind);\n/**\r\n * E.g. ```const toListingPath = toPathByRouteName('ListingPage', routes);```\r\n * Then we can generate listing paths with given params (```toListingPath({ id: uuidX })```)\r\n */\n\n\nconst toPathByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n\n  if (!route) {\n    throw new Error(`Path \"${nameToFind}\" was not found.`);\n  }\n\n  return compile(route.path);\n};\n/**\r\n * Shorthand for single path call. (```pathByRouteName('ListingPage', routes, { id: uuidX });```)\r\n */\n\n\nexport const pathByRouteName = (nameToFind, routes, params = {}) => {\n  const hasEmptySlug = params && params.hasOwnProperty('slug') && params.slug === '';\n  const pathParams = hasEmptySlug ? { ...params,\n    slug: 'no-slug'\n  } : params;\n  return toPathByRouteName(nameToFind, routes)(pathParams);\n};\n/**\r\n * Find the matching routes and their params for the given pathname\r\n *\r\n * @param {String} pathname - Full URL path from root with possible\r\n * search params and hash included\r\n *\r\n * @return {Array<{ route, params }>} - All matches as { route, params } objects if matches has\r\n * exact flag set to false. If not, an array containing just the first matched exact route is returned.\r\n */\n\nexport const matchPathname = (pathname, routeConfiguration) => {\n  const matchedRoutes = routeConfiguration.reduce((matches, route) => {\n    const {\n      path,\n      exact = true\n    } = route;\n    const match = matchPath(pathname, {\n      path,\n      exact\n    });\n\n    if (match) {\n      matches.push({\n        route,\n        params: match.params || {}\n      });\n    }\n\n    return matches;\n  }, []);\n  const matchedExactRoute = matchedRoutes.find(r => {\n    return r.exact === true || r.exact == null;\n  }); // We return matched 'exact' path route only if such exists\n  // and all matches if no exact flag exists.\n\n  return matchedExactRoute ? [matchedExactRoute] : matchedRoutes;\n};\n/**\r\n * ResourceLocatorString is used to direct webapp to correct page.\r\n * In contrast to Universal Resource Locator (URL), this doesn't contain protocol, host, or port.\r\n */\n\nexport const createResourceLocatorString = (routeName, routes, pathParams = {}, searchParams = {}, hash = '') => {\n  const searchQuery = stringify(searchParams);\n  const includeSearchQuery = searchQuery.length > 0 ? `?${searchQuery}` : '';\n  const path = pathByRouteName(routeName, routes, pathParams);\n  return `${path}${includeSearchQuery}${hash}`;\n};\n/**\r\n * Find component related to route name\r\n * E.g. `const PageComponent = findComponentByRouteName('CheckoutPage', routes);`\r\n * Then we can call static methods of given component:\r\n * `dispatch(PageComponent.setInitialValues({ listing, bookingDates }));`\r\n *\r\n * @param {String} nameToFind - Route name\r\n * @param {Array<{ route }>} routes - Route configuration as flat array.\r\n *\r\n * @return {Route} - Route that matches the given route name.\r\n */\n\nexport const findRouteByRouteName = (nameToFind, routes) => {\n  const route = findRouteByName(nameToFind, routes);\n\n  if (!route) {\n    throw new Error(`Component \"${nameToFind}\" was not found.`);\n  }\n\n  return route;\n};\n/**\r\n * Get the canonical URL from the given location\r\n *\r\n * @param {Array<{ route }>} routes - Route configuration as flat array\r\n * @param {Object} location - location object from React Router\r\n *\r\n * @return {String} Canonical URL of the given location\r\n *\r\n */\n\nexport const canonicalRoutePath = (routes, location, pathOnly = false) => {\n  const {\n    pathname,\n    search,\n    hash\n  } = location;\n  const matches = matchPathname(pathname, routes);\n  const isListingRoute = matches.length === 1 && matches[0].route.name === 'ListingPage';\n\n  if (isListingRoute) {\n    // Remove the dynamic slug from the listing page canonical URL\n    // Remove possible trailing slash\n    const cleanedPathName = pathname.replace(/\\/$/, '');\n    const parts = cleanedPathName.split('/');\n\n    if (parts.length !== 4) {\n      throw new Error('Expected ListingPage route to have 4 parts');\n    }\n\n    const canonicalListingPathname = `/${parts[1]}/${parts[3]}`;\n    return pathOnly ? canonicalListingPathname : `${canonicalListingPathname}${search}${hash}`;\n  }\n\n  return pathOnly ? pathname : `${pathname}${search}${hash}`;\n};","map":{"version":3,"sources":["D:/Amardeep/tarek_project/ftw-product/src/util/routes.js"],"names":["find","matchPath","compile","stringify","findRouteByName","nameToFind","routes","route","name","toPathByRouteName","Error","path","pathByRouteName","params","hasEmptySlug","hasOwnProperty","slug","pathParams","matchPathname","pathname","routeConfiguration","matchedRoutes","reduce","matches","exact","match","push","matchedExactRoute","r","createResourceLocatorString","routeName","searchParams","hash","searchQuery","includeSearchQuery","length","findRouteByRouteName","canonicalRoutePath","location","pathOnly","search","isListingRoute","cleanedPathName","replace","parts","split","canonicalListingPathname"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,aAAjB;AACA,SAASC,SAAT,QAA0B,kBAA1B;AACA,SAASC,OAAT,QAAwB,gBAAxB;AACA,SAASC,SAAT,QAA0B,cAA1B;;AAEA,MAAMC,eAAe,GAAG,CAACC,UAAD,EAAaC,MAAb,KAAwBN,IAAI,CAACM,MAAD,EAASC,KAAK,IAAIA,KAAK,CAACC,IAAN,KAAeH,UAAjC,CAApD;AAEA;AACA;AACA;AACA;;;AACA,MAAMI,iBAAiB,GAAG,CAACJ,UAAD,EAAaC,MAAb,KAAwB;AAChD,QAAMC,KAAK,GAAGH,eAAe,CAACC,UAAD,EAAaC,MAAb,CAA7B;;AACA,MAAI,CAACC,KAAL,EAAY;AACV,UAAM,IAAIG,KAAJ,CAAW,SAAQL,UAAW,kBAA9B,CAAN;AACD;;AACD,SAAOH,OAAO,CAACK,KAAK,CAACI,IAAP,CAAd;AACD,CAND;AAQA;AACA;AACA;;;AACA,OAAO,MAAMC,eAAe,GAAG,CAACP,UAAD,EAAaC,MAAb,EAAqBO,MAAM,GAAG,EAA9B,KAAqC;AAClE,QAAMC,YAAY,GAAGD,MAAM,IAAIA,MAAM,CAACE,cAAP,CAAsB,MAAtB,CAAV,IAA2CF,MAAM,CAACG,IAAP,KAAgB,EAAhF;AACA,QAAMC,UAAU,GAAGH,YAAY,GAAG,EAAE,GAAGD,MAAL;AAAaG,IAAAA,IAAI,EAAE;AAAnB,GAAH,GAAoCH,MAAnE;AACA,SAAOJ,iBAAiB,CAACJ,UAAD,EAAaC,MAAb,CAAjB,CAAsCW,UAAtC,CAAP;AACD,CAJM;AAMP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAG,CAACC,QAAD,EAAWC,kBAAX,KAAkC;AAC7D,QAAMC,aAAa,GAAGD,kBAAkB,CAACE,MAAnB,CAA0B,CAACC,OAAD,EAAUhB,KAAV,KAAoB;AAClE,UAAM;AAAEI,MAAAA,IAAF;AAAQa,MAAAA,KAAK,GAAG;AAAhB,QAAyBjB,KAA/B;AACA,UAAMkB,KAAK,GAAGxB,SAAS,CAACkB,QAAD,EAAW;AAAER,MAAAA,IAAF;AAAQa,MAAAA;AAAR,KAAX,CAAvB;;AACA,QAAIC,KAAJ,EAAW;AACTF,MAAAA,OAAO,CAACG,IAAR,CAAa;AACXnB,QAAAA,KADW;AAEXM,QAAAA,MAAM,EAAEY,KAAK,CAACZ,MAAN,IAAgB;AAFb,OAAb;AAID;;AACD,WAAOU,OAAP;AACD,GAVqB,EAUnB,EAVmB,CAAtB;AAYA,QAAMI,iBAAiB,GAAGN,aAAa,CAACrB,IAAd,CAAmB4B,CAAC,IAAI;AAChD,WAAOA,CAAC,CAACJ,KAAF,KAAY,IAAZ,IAAoBI,CAAC,CAACJ,KAAF,IAAW,IAAtC;AACD,GAFyB,CAA1B,CAb6D,CAiB7D;AACA;;AACA,SAAOG,iBAAiB,GAAG,CAACA,iBAAD,CAAH,GAAyBN,aAAjD;AACD,CApBM;AAsBP;AACA;AACA;AACA;;AACA,OAAO,MAAMQ,2BAA2B,GAAG,CACzCC,SADyC,EAEzCxB,MAFyC,EAGzCW,UAAU,GAAG,EAH4B,EAIzCc,YAAY,GAAG,EAJ0B,EAKzCC,IAAI,GAAG,EALkC,KAMtC;AACH,QAAMC,WAAW,GAAG9B,SAAS,CAAC4B,YAAD,CAA7B;AACA,QAAMG,kBAAkB,GAAGD,WAAW,CAACE,MAAZ,GAAqB,CAArB,GAA0B,IAAGF,WAAY,EAAzC,GAA6C,EAAxE;AACA,QAAMtB,IAAI,GAAGC,eAAe,CAACkB,SAAD,EAAYxB,MAAZ,EAAoBW,UAApB,CAA5B;AACA,SAAQ,GAAEN,IAAK,GAAEuB,kBAAmB,GAAEF,IAAK,EAA3C;AACD,CAXM;AAaP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMI,oBAAoB,GAAG,CAAC/B,UAAD,EAAaC,MAAb,KAAwB;AAC1D,QAAMC,KAAK,GAAGH,eAAe,CAACC,UAAD,EAAaC,MAAb,CAA7B;;AACA,MAAI,CAACC,KAAL,EAAY;AACV,UAAM,IAAIG,KAAJ,CAAW,cAAaL,UAAW,kBAAnC,CAAN;AACD;;AACD,SAAOE,KAAP;AACD,CANM;AAQP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAM8B,kBAAkB,GAAG,CAAC/B,MAAD,EAASgC,QAAT,EAAmBC,QAAQ,GAAG,KAA9B,KAAwC;AACxE,QAAM;AAAEpB,IAAAA,QAAF;AAAYqB,IAAAA,MAAZ;AAAoBR,IAAAA;AAApB,MAA6BM,QAAnC;AAEA,QAAMf,OAAO,GAAGL,aAAa,CAACC,QAAD,EAAWb,MAAX,CAA7B;AACA,QAAMmC,cAAc,GAAGlB,OAAO,CAACY,MAAR,KAAmB,CAAnB,IAAwBZ,OAAO,CAAC,CAAD,CAAP,CAAWhB,KAAX,CAAiBC,IAAjB,KAA0B,aAAzE;;AAEA,MAAIiC,cAAJ,EAAoB;AAClB;AAEA;AACA,UAAMC,eAAe,GAAGvB,QAAQ,CAACwB,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAAxB;AACA,UAAMC,KAAK,GAAGF,eAAe,CAACG,KAAhB,CAAsB,GAAtB,CAAd;;AAEA,QAAID,KAAK,CAACT,MAAN,KAAiB,CAArB,EAAwB;AACtB,YAAM,IAAIzB,KAAJ,CAAU,4CAAV,CAAN;AACD;;AACD,UAAMoC,wBAAwB,GAAI,IAAGF,KAAK,CAAC,CAAD,CAAI,IAAGA,KAAK,CAAC,CAAD,CAAI,EAA1D;AACA,WAAOL,QAAQ,GAAGO,wBAAH,GAA+B,GAAEA,wBAAyB,GAAEN,MAAO,GAAER,IAAK,EAAzF;AACD;;AAED,SAAOO,QAAQ,GAAGpB,QAAH,GAAe,GAAEA,QAAS,GAAEqB,MAAO,GAAER,IAAK,EAAzD;AACD,CArBM","sourcesContent":["import find from 'lodash/find';\r\nimport { matchPath } from 'react-router-dom';\r\nimport { compile } from 'path-to-regexp';\r\nimport { stringify } from './urlHelpers';\r\n\r\nconst findRouteByName = (nameToFind, routes) => find(routes, route => route.name === nameToFind);\r\n\r\n/**\r\n * E.g. ```const toListingPath = toPathByRouteName('ListingPage', routes);```\r\n * Then we can generate listing paths with given params (```toListingPath({ id: uuidX })```)\r\n */\r\nconst toPathByRouteName = (nameToFind, routes) => {\r\n  const route = findRouteByName(nameToFind, routes);\r\n  if (!route) {\r\n    throw new Error(`Path \"${nameToFind}\" was not found.`);\r\n  }\r\n  return compile(route.path);\r\n};\r\n\r\n/**\r\n * Shorthand for single path call. (```pathByRouteName('ListingPage', routes, { id: uuidX });```)\r\n */\r\nexport const pathByRouteName = (nameToFind, routes, params = {}) => {\r\n  const hasEmptySlug = params && params.hasOwnProperty('slug') && params.slug === '';\r\n  const pathParams = hasEmptySlug ? { ...params, slug: 'no-slug' } : params;\r\n  return toPathByRouteName(nameToFind, routes)(pathParams);\r\n};\r\n\r\n/**\r\n * Find the matching routes and their params for the given pathname\r\n *\r\n * @param {String} pathname - Full URL path from root with possible\r\n * search params and hash included\r\n *\r\n * @return {Array<{ route, params }>} - All matches as { route, params } objects if matches has\r\n * exact flag set to false. If not, an array containing just the first matched exact route is returned.\r\n */\r\nexport const matchPathname = (pathname, routeConfiguration) => {\r\n  const matchedRoutes = routeConfiguration.reduce((matches, route) => {\r\n    const { path, exact = true } = route;\r\n    const match = matchPath(pathname, { path, exact });\r\n    if (match) {\r\n      matches.push({\r\n        route,\r\n        params: match.params || {},\r\n      });\r\n    }\r\n    return matches;\r\n  }, []);\r\n\r\n  const matchedExactRoute = matchedRoutes.find(r => {\r\n    return r.exact === true || r.exact == null;\r\n  });\r\n\r\n  // We return matched 'exact' path route only if such exists\r\n  // and all matches if no exact flag exists.\r\n  return matchedExactRoute ? [matchedExactRoute] : matchedRoutes;\r\n};\r\n\r\n/**\r\n * ResourceLocatorString is used to direct webapp to correct page.\r\n * In contrast to Universal Resource Locator (URL), this doesn't contain protocol, host, or port.\r\n */\r\nexport const createResourceLocatorString = (\r\n  routeName,\r\n  routes,\r\n  pathParams = {},\r\n  searchParams = {},\r\n  hash = ''\r\n) => {\r\n  const searchQuery = stringify(searchParams);\r\n  const includeSearchQuery = searchQuery.length > 0 ? `?${searchQuery}` : '';\r\n  const path = pathByRouteName(routeName, routes, pathParams);\r\n  return `${path}${includeSearchQuery}${hash}`;\r\n};\r\n\r\n/**\r\n * Find component related to route name\r\n * E.g. `const PageComponent = findComponentByRouteName('CheckoutPage', routes);`\r\n * Then we can call static methods of given component:\r\n * `dispatch(PageComponent.setInitialValues({ listing, bookingDates }));`\r\n *\r\n * @param {String} nameToFind - Route name\r\n * @param {Array<{ route }>} routes - Route configuration as flat array.\r\n *\r\n * @return {Route} - Route that matches the given route name.\r\n */\r\nexport const findRouteByRouteName = (nameToFind, routes) => {\r\n  const route = findRouteByName(nameToFind, routes);\r\n  if (!route) {\r\n    throw new Error(`Component \"${nameToFind}\" was not found.`);\r\n  }\r\n  return route;\r\n};\r\n\r\n/**\r\n * Get the canonical URL from the given location\r\n *\r\n * @param {Array<{ route }>} routes - Route configuration as flat array\r\n * @param {Object} location - location object from React Router\r\n *\r\n * @return {String} Canonical URL of the given location\r\n *\r\n */\r\nexport const canonicalRoutePath = (routes, location, pathOnly = false) => {\r\n  const { pathname, search, hash } = location;\r\n\r\n  const matches = matchPathname(pathname, routes);\r\n  const isListingRoute = matches.length === 1 && matches[0].route.name === 'ListingPage';\r\n\r\n  if (isListingRoute) {\r\n    // Remove the dynamic slug from the listing page canonical URL\r\n\r\n    // Remove possible trailing slash\r\n    const cleanedPathName = pathname.replace(/\\/$/, '');\r\n    const parts = cleanedPathName.split('/');\r\n\r\n    if (parts.length !== 4) {\r\n      throw new Error('Expected ListingPage route to have 4 parts');\r\n    }\r\n    const canonicalListingPathname = `/${parts[1]}/${parts[3]}`;\r\n    return pathOnly ? canonicalListingPathname : `${canonicalListingPathname}${search}${hash}`;\r\n  }\r\n\r\n  return pathOnly ? pathname : `${pathname}${search}${hash}`;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}