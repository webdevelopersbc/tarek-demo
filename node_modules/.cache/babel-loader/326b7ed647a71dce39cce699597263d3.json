{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { Scope } from '@sentry/hub';\nimport { Dsn, isPrimitive, isThenable, logger, normalize, SyncPromise, timestampWithMs, truncate, uuid4 } from '@sentry/utils';\nimport { setupIntegrations } from './integration';\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\n\nvar BaseClient =\n/** @class */\nfunction () {\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  function BaseClient(backendClass, options) {\n    /** Array of used integrations. */\n    this._integrations = {};\n    /** Is the client still processing a call? */\n\n    this._processing = false;\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = new Dsn(options.dsn);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureException = function (exception, hint, scope) {\n    var _this = this;\n\n    var eventId = hint && hint.event_id;\n    this._processing = true;\n\n    this._getBackend().eventFromException(exception, hint).then(function (event) {\n      eventId = _this.captureEvent(event, hint, scope);\n    });\n\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureMessage = function (message, level, hint, scope) {\n    var _this = this;\n\n    var eventId = hint && hint.event_id;\n    this._processing = true;\n    var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(\"\" + message, level, hint) : this._getBackend().eventFromException(message, hint);\n    promisedEvent.then(function (event) {\n      eventId = _this.captureEvent(event, hint, scope);\n    });\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureEvent = function (event, hint, scope) {\n    var _this = this;\n\n    var eventId = hint && hint.event_id;\n    this._processing = true;\n\n    this._processEvent(event, hint, scope).then(function (finalEvent) {\n      // We need to check for finalEvent in case beforeSend returned null\n      eventId = finalEvent && finalEvent.event_id;\n      _this._processing = false;\n    }).then(null, function (reason) {\n      logger.error(reason);\n      _this._processing = false;\n    });\n\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getDsn = function () {\n    return this._dsn;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getOptions = function () {\n    return this._options;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.flush = function (timeout) {\n    var _this = this;\n\n    return this._isClientProcessing(timeout).then(function (status) {\n      clearInterval(status.interval);\n      return _this._getBackend().getTransport().close(timeout).then(function (transportFlushed) {\n        return status.ready && transportFlushed;\n      });\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.close = function (timeout) {\n    var _this = this;\n\n    return this.flush(timeout).then(function (result) {\n      _this.getOptions().enabled = false;\n      return result;\n    });\n  };\n  /**\n   * Sets up the integrations\n   */\n\n\n  BaseClient.prototype.setupIntegrations = function () {\n    if (this._isEnabled()) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getIntegration = function (integration) {\n    try {\n      return this._integrations[integration.id] || null;\n    } catch (_oO) {\n      logger.warn(\"Cannot retrieve integration \" + integration.id + \" from the current Client\");\n      return null;\n    }\n  };\n  /** Waits for the client to be done with processing. */\n\n\n  BaseClient.prototype._isClientProcessing = function (timeout) {\n    var _this = this;\n\n    return new SyncPromise(function (resolve) {\n      var ticked = 0;\n      var tick = 1;\n      var interval = 0;\n      clearInterval(interval);\n      interval = setInterval(function () {\n        if (!_this._processing) {\n          resolve({\n            interval: interval,\n            ready: true\n          });\n        } else {\n          ticked += tick;\n\n          if (timeout && ticked >= timeout) {\n            resolve({\n              interval: interval,\n              ready: false\n            });\n          }\n        }\n      }, tick);\n    });\n  };\n  /** Returns the current backend. */\n\n\n  BaseClient.prototype._getBackend = function () {\n    return this._backend;\n  };\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n\n\n  BaseClient.prototype._isEnabled = function () {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  };\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n\n\n  BaseClient.prototype._prepareEvent = function (event, scope, hint) {\n    var _this = this;\n\n    var _a = this.getOptions().normalizeDepth,\n        normalizeDepth = _a === void 0 ? 3 : _a;\n\n    var prepared = tslib_1.__assign({}, event, {\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || timestampWithMs()\n    });\n\n    this._applyClientOptions(prepared);\n\n    this._applyIntegrationsMetadata(prepared); // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n\n\n    var finalScope = scope;\n\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    } // We prepare the result here with a resolved Event.\n\n\n    var result = SyncPromise.resolve(prepared); // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(function (evt) {\n      // tslint:disable-next-line:strict-type-predicates\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return _this._normalizeEvent(evt, normalizeDepth);\n      }\n\n      return evt;\n    });\n  };\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n\n\n  BaseClient.prototype._normalizeEvent = function (event, depth) {\n    if (!event) {\n      return null;\n    } // tslint:disable:no-unsafe-any\n\n\n    var normalized = tslib_1.__assign({}, event, event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(function (b) {\n        return tslib_1.__assign({}, b, b.data && {\n          data: normalize(b.data, depth)\n        });\n      })\n    }, event.user && {\n      user: normalize(event.user, depth)\n    }, event.contexts && {\n      contexts: normalize(event.contexts, depth)\n    }, event.extra && {\n      extra: normalize(event.extra, depth)\n    }); // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n\n\n    if (event.contexts && event.contexts.trace) {\n      normalized.contexts.trace = event.contexts.trace;\n    }\n\n    return normalized;\n  };\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n\n\n  BaseClient.prototype._applyClientOptions = function (event) {\n    var _a = this.getOptions(),\n        environment = _a.environment,\n        release = _a.release,\n        dist = _a.dist,\n        _b = _a.maxValueLength,\n        maxValueLength = _b === void 0 ? 250 : _b;\n\n    if (event.environment === undefined && environment !== undefined) {\n      event.environment = environment;\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    var exception = event.exception && event.exception.values && event.exception.values[0];\n\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    var request = event.request;\n\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  };\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n\n\n  BaseClient.prototype._applyIntegrationsMetadata = function (event) {\n    var sdkInfo = event.sdk;\n    var integrationsArray = Object.keys(this._integrations);\n\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  };\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n\n\n  BaseClient.prototype._sendEvent = function (event) {\n    this._getBackend().sendEvent(event);\n  };\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n\n\n  BaseClient.prototype._processEvent = function (event, hint, scope) {\n    var _this = this;\n\n    var _a = this.getOptions(),\n        beforeSend = _a.beforeSend,\n        sampleRate = _a.sampleRate;\n\n    if (!this._isEnabled()) {\n      return SyncPromise.reject('SDK not enabled, will not send event.');\n    }\n\n    var isTransaction = event.type === 'transaction'; // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return SyncPromise.reject('This event has been sampled, will not send event.');\n    }\n\n    return new SyncPromise(function (resolve, reject) {\n      _this._prepareEvent(event, scope, hint).then(function (prepared) {\n        if (prepared === null) {\n          reject('An event processor returned null, will not send event.');\n          return;\n        }\n\n        var finalEvent = prepared;\n        var isInternalException = hint && hint.data && hint.data.__sentry__ === true; // We skip beforeSend in case of transactions\n\n        if (isInternalException || !beforeSend || isTransaction) {\n          _this._sendEvent(finalEvent);\n\n          resolve(finalEvent);\n          return;\n        }\n\n        var beforeSendResult = beforeSend(prepared, hint); // tslint:disable-next-line:strict-type-predicates\n\n        if (typeof beforeSendResult === 'undefined') {\n          logger.error('`beforeSend` method has to return `null` or a valid event.');\n        } else if (isThenable(beforeSendResult)) {\n          _this._handleAsyncBeforeSend(beforeSendResult, resolve, reject);\n        } else {\n          finalEvent = beforeSendResult;\n\n          if (finalEvent === null) {\n            logger.log('`beforeSend` returned `null`, will not send event.');\n            resolve(null);\n            return;\n          } // From here on we are really async\n\n\n          _this._sendEvent(finalEvent);\n\n          resolve(finalEvent);\n        }\n      }).then(null, function (reason) {\n        _this.captureException(reason, {\n          data: {\n            __sentry__: true\n          },\n          originalException: reason\n        });\n\n        reject(\"Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: \" + reason);\n      });\n    });\n  };\n  /**\n   * Resolves before send Promise and calls resolve/reject on parent SyncPromise.\n   */\n\n\n  BaseClient.prototype._handleAsyncBeforeSend = function (beforeSend, resolve, reject) {\n    var _this = this;\n\n    beforeSend.then(function (processedEvent) {\n      if (processedEvent === null) {\n        reject('`beforeSend` returned `null`, will not send event.');\n        return;\n      } // From here on we are really async\n\n\n      _this._sendEvent(processedEvent);\n\n      resolve(processedEvent);\n    }).then(null, function (e) {\n      reject(\"beforeSend rejected with \" + e);\n    });\n  };\n\n  return BaseClient;\n}();\n\nexport { BaseClient };","map":{"version":3,"sources":["../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scope } from '@sentry/hub';\nimport { Client, Event, EventHint, Integration, IntegrationClass, Options, Severity } from '@sentry/types';\nimport {\n  Dsn,\n  isPrimitive,\n  isThenable,\n  logger,\n  normalize,\n  SyncPromise,\n  timestampWithMs,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the environment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: Dsn;\n\n  /** Array of used integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Is the client still processing a call? */\n  protected _processing: boolean = false;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = new Dsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n    this._processing = true;\n\n    this._getBackend()\n      .eventFromException(exception, hint)\n      .then(event => {\n        eventId = this.captureEvent(event, hint, scope);\n      });\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n    this._processing = true;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(`${message}`, level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    promisedEvent.then(event => {\n      eventId = this.captureEvent(event, hint, scope);\n    });\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n    this._processing = true;\n\n    this._processEvent(event, hint, scope)\n      .then(finalEvent => {\n        // We need to check for finalEvent in case beforeSend returned null\n        eventId = finalEvent && finalEvent.event_id;\n        this._processing = false;\n      })\n      .then(null, reason => {\n        logger.error(reason);\n        this._processing = false;\n      });\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): Dsn | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    return this._isClientProcessing(timeout).then(status => {\n      clearInterval(status.interval);\n      return this._getBackend()\n        .getTransport()\n        .close(timeout)\n        .then(transportFlushed => status.ready && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled()) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Waits for the client to be done with processing. */\n  protected _isClientProcessing(timeout?: number): PromiseLike<{ ready: boolean; interval: number }> {\n    return new SyncPromise<{ ready: boolean; interval: number }>(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      let interval = 0;\n      clearInterval(interval);\n\n      interval = (setInterval(() => {\n        if (!this._processing) {\n          resolve({\n            interval,\n            ready: true,\n          });\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            resolve({\n              interval,\n              ready: false,\n            });\n          }\n        }\n      }, tick) as unknown) as number;\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    const { normalizeDepth = 3 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || timestampWithMs(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = SyncPromise.resolve<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      // tslint:disable-next-line:strict-type-predicates\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    // tslint:disable:no-unsafe-any\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth),\n      }),\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      normalized.contexts.trace = event.contexts.trace;\n    }\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const { environment, release, dist, maxValueLength = 250 } = this.getOptions();\n\n    if (event.environment === undefined && environment !== undefined) {\n      event.environment = environment;\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const sdkInfo = event.sdk;\n    const integrationsArray = Object.keys(this._integrations);\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  }\n\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  protected _sendEvent(event: Event): void {\n    this._getBackend().sendEvent(event);\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event> {\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (!this._isEnabled()) {\n      return SyncPromise.reject('SDK not enabled, will not send event.');\n    }\n\n    const isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return SyncPromise.reject('This event has been sampled, will not send event.');\n    }\n\n    return new SyncPromise((resolve, reject) => {\n      this._prepareEvent(event, scope, hint)\n        .then(prepared => {\n          if (prepared === null) {\n            reject('An event processor returned null, will not send event.');\n            return;\n          }\n\n          let finalEvent: Event | null = prepared;\n\n          const isInternalException = hint && hint.data && (hint.data as { [key: string]: any }).__sentry__ === true;\n          // We skip beforeSend in case of transactions\n          if (isInternalException || !beforeSend || isTransaction) {\n            this._sendEvent(finalEvent);\n            resolve(finalEvent);\n            return;\n          }\n\n          const beforeSendResult = beforeSend(prepared, hint);\n          // tslint:disable-next-line:strict-type-predicates\n          if (typeof beforeSendResult === 'undefined') {\n            logger.error('`beforeSend` method has to return `null` or a valid event.');\n          } else if (isThenable(beforeSendResult)) {\n            this._handleAsyncBeforeSend(beforeSendResult as PromiseLike<Event | null>, resolve, reject);\n          } else {\n            finalEvent = beforeSendResult as Event | null;\n\n            if (finalEvent === null) {\n              logger.log('`beforeSend` returned `null`, will not send event.');\n              resolve(null);\n              return;\n            }\n\n            // From here on we are really async\n            this._sendEvent(finalEvent);\n            resolve(finalEvent);\n          }\n        })\n        .then(null, reason => {\n          this.captureException(reason, {\n            data: {\n              __sentry__: true,\n            },\n            originalException: reason as Error,\n          });\n          reject(\n            `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n          );\n        });\n    });\n  }\n\n  /**\n   * Resolves before send Promise and calls resolve/reject on parent SyncPromise.\n   */\n  private _handleAsyncBeforeSend(\n    beforeSend: PromiseLike<Event | null>,\n    resolve: (event: Event) => void,\n    reject: (reason: string) => void,\n  ): void {\n    beforeSend\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          reject('`beforeSend` returned `null`, will not send event.');\n          return;\n        }\n        // From here on we are really async\n        this._sendEvent(processedEvent);\n        resolve(processedEvent);\n      })\n      .then(null, e => {\n        reject(`beforeSend rejected with ${e}`);\n      });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}